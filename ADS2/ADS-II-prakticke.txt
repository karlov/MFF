ADS II prakticke
#define Text
1. printf(); Najdƒõte pro dan√Ω ≈ôetƒõzec co nejdel≈°√≠ pod≈ôetƒõzec, kter√Ω je souƒçasnƒõ prefixem i suffixem (vlastn√≠m).
	{
		viz 20. PrefixFunction()
	}
14. scanf("Ivona") N√°hrdeln√≠k je cyklick√Ω ≈ôetƒõzec, kter√Ω nem√° urƒçen√Ω ani zaƒç√°tek, ani smƒõr ƒçten√≠. Jak rozhodnout, zda jsou si dva n√°hrdeln√≠ky rovny?

7. scanf("Ivona") V dan√©m ≈ôetƒõzci nad abecedou {a,b} chceme nal√©zt nejdel≈°√≠ Fibonacciho podslovo. Fibonacciho slova jsou definov√°na takto: F1=a, F2=b, Fn+2=FnFn+1.
16. scanf("Kyrylo") Je d√°n slovn√≠k a text. Navrhnƒõte algoritmus, kter√Ω pro ka≈æd√© slovo ze slovn√≠ku spoƒçte, kolikr√°t se v textu vyskytuje jako pod≈ôetƒõzec.
20. printf(); Jak zjistit, jestli je zadan√Ω ≈ôetƒõzec periodick√Ω? Tedy zda pro dan√Ω ≈ôetƒõzec Œ± existuje ≈ôetƒõzec Œ≤ a ƒç√≠slo k>1 tak, ≈æe Œ± = Œ≤k.
	{
		Tak druh√Ω pokus. Pomoci KMP najdu nejdel≈°√≠ Sufix, kter√Ω je z√°rove≈à Prefixem slova (budou mƒõ zaj√≠mat v≈°echny takov√© kromƒõ trivi√°ln√≠ho p≈ô√≠padu, kdy≈æ prefix = sufix = cel√© slovo). Pak pokud takov√Ω existuje, jeho d√©lka je K a N se dƒõl√≠ beze zbytku (N - K), tak slovo je periodick√©.

	Pro v√Ωpoƒçet d√©lky takov√©ho sufixu/prefixu pou≈æij√≠ n√°sleduj√≠c√≠ funkce. Kter√° spoƒç√≠t√° tzv. prefixovou funkci KMP.

	void PrefixFunction(string str)
	{
	    int longest_prefix[str.length];
	    int length = 0; //Zat√≠m nejdel≈°√≠ suffix
	    int i;
	 
	    longest_prefix[0] = 0;
	    i = 1;

	    while (i < str.length)
	    {
	       if (str[i] == str[length])
	       {
	           ++length;
	           longest_prefix[i] = length;
	           ++i;
	       }
	       else
	       {
	          if (length != 0)
	          {
	             length = longest_prefix[length-1];
	          }
	          else // if (length == 0)
	          {
	             longest_prefix[i] = 0;
	             ++i;
	          }
	       }
	    }
	}

	Z toho pole vezmu posledn√≠ prvek(longest_prefix[longest_prefix.Length - 1]), co≈æ je d√©lka hledan√©ho sufixu/prefixu K.

	Jeliko≈æ tento algoritmus je KMP a jedno porovnan√≠ nav√≠c, ƒçasov√° slo≈æitost je O(N);
	}
26. scanf("Kyrylo") Je d√°n text a ƒç√≠slo K. Naleznƒõte pod≈ôetƒõzec d√©lky K, kter√Ω se v textu vyskytuje nejƒçastƒõji.
22. scanf("Kyrylo") Je d√°n ≈ôetƒõzec a ƒç√≠slo K. Kter√Ω pod≈ôetƒõzec d√©lky K je nejƒçetnƒõj≈°√≠?

#define Toky
3. scanf("Ivona") Mƒõjme dƒõravou ≈°achnovnici. Jak ji pokr√Ωt kostkami 1√ó2 pol√≠ƒçka?

17. scanf("Ivona") Mƒõjme strom, jeho≈æ vrcholy jsou opat≈ôeny celoƒç√≠seln√Ωmi vahami. Chceme nal√©zt nez√°vislou mno≈æinu, jej√≠≈æ souƒçet vah je nejvƒõt≈°√≠ mo≈æn√Ω.
18. printf(); Zjistit, jak rychle bƒõ≈æ√≠ Goldberg≈Øv algoritmus na s√≠ti s jednotkov√Ωmi kapacitami
	{
		Ty jednotkove kapacity zaridi, ze nemame nenasycena prevedeni. To by nam zbyvala slozitost O(N^3 + NM). Jde to ale i na O(NM), kdyz si trosku vylepsime odhad poctu zvednuti.
		Diky implementaci nas jedno zvednuti stoji ‚â§ N. Kazda hrana ma dva vrcholy a kolikrat muzeme zvednout vrchol, uz vime, ze?
		Takze pro kazdou hranu mame ‚â§ 4N zvednuti, tedy cas na zvedani taky O(NM).
		MJ mi rikal jeste jinou verzi dukazu O(NM) zvednuti, a to pres scitani vstupnich a vystupnich stupnu vrcholu - nicmene uvedeny postup je taky spravny.
	}
19. printf(); Je d√°n orientovan√Ω graf a jeho vrcholy u, v. Chceme nal√©zt co nejv√≠ce hranovƒõ disjunktn√≠ch cest z u do v.
	Za zdroj si vezmu U jako zdroj a V jako stok. Ka≈æd√© hranƒõ p≈ôi≈ôad√≠m kapacitu 1, v p≈ô√≠padƒõ vrcholovƒõ z disjunktn√≠ch cest je≈°tƒõ vrchol≈Øm kapacitu 1.
	Pust√≠m na tento graf nap≈ô F-F algoritmus. Uv√°≈æ√≠m ty hrany, kter√Ωm algoritmus p≈ôi≈ôad√≠ tok 1. Zb√Ωv√° je≈°tƒõ ≈ôe≈°it p≈ô√≠pad kdy≈æ cesta obsahuje cyklus.
	Staƒç√≠ proj√≠t graf a pokud nƒõjak√Ω vrchol potk√°m dvakr√°t, tak je tam cyklus, kter√Ω mus√≠m smazat. Kdy≈æ sma≈æu cyklus tak dostanu cestu od U do V.
	Naleznutou cestu sma≈æu, v hledan√≠ cest budu pokraƒçovat pokud Tok nen√≠ nulov√Ω.

	ƒçasov√° slo≈æitost: F-F O(m*n), jeliko≈æ cesty jsou disjunktn√≠ jej√≠ch hledan√≠ po ukonƒçen√≠ F-F je O(m). Tak≈æe O(m*n) dohromady.

	//Vrcholove
	Tak z vrcholu udƒõl√°m hranu n√°sleduj√≠c√≠m zp≈Øsobem:
	Pro p≈Øvodn√≠ vrchol a p≈ôid√°m 2 vrcholy a1, a2. Kter√© spoj√≠m hranou (a1, a2). Pak je≈°tƒõ spoj√≠m v≈°echny vrcholy, kter√© p≈ôedt√≠m byly spojen√Ω hranou s a: (a, b), s a2. Neboli pro v≈°echny b : (a, b) byla hrana v p≈Øvodn√≠m grafu, vytvo≈ô√≠m hranu (a2, b).

	Pak m≈Ø≈æu pou≈æit algoritmus pro hranovƒõ disjunktn√≠ cesty na modifikovan√Ω graf, proto≈æe vrcholovƒõ disjunktn√≠ cesta je hranov√© disjunktn√≠.
8. printf(); Pro dan√Ω neorientovan√Ω graf chceme nal√©zt nejvƒõt≈°√≠ k takov√©, ≈æe graf je hranovƒõ k-souvisl√Ω.
	{
		Kdy≈æ budu spou≈°tƒõt algoritmus na hledan√≠ max toku na v≈°echny dvojice vrcholu, tak urƒçitƒõ v≈°echny hranovƒõ disjunktn√≠ cesty potk√°m nƒõkolikr√°t.
		Tak≈æe staƒç√≠ zafixovat nƒõjak√Ω vrchol(t≈ôeba k), oznaƒçit ho za Zdroj. Za Stock budu postupnƒõ oznaƒçovat vrcholy z V\{k}(Je mo≈æn√© taky neuva≈æovat sousedy k). Minimum z toku se bude rovnat hranov√© souvislosti grafu. Zastav√≠m se, kdy≈æ poƒçet iteraci(I) p≈ôes√°hne zat√≠m minim√°ln√≠ tok(Proto≈æe hranov√° souvislost je omezen√° min stupnƒõm vrcholu a 2|E|/|V|)

		D≈Økaz korektnost√≠: Minim√°ln√≠ tok ze v≈°ech iteraci oznaƒç√≠m za F.
		Z Mengerov√© vƒõty existuje Separator (mno≈æina hran, po odebran√≠ kter√Ωch graf stane nesouvisl√Ω). Velikost separ√°toru se rovna souvislost√≠ grafu(Oznaƒç√≠m za R) . Aspo≈à jeden z mno≈æiny vrcholu V1, V2, ... V(r+1), kde r+1 index, nen√≠ v tom ≈ôezu-separ√°toru. Nech≈• to bude vrchol Vj. Existuje vrchol Vt z separ√°toru takov√Ω, ≈æe #hranovƒõ-disjunktn√≠ch cest z Vt do Vj = R.

		F >= R,
		I > F
		I >= R + 1

		Z toho C = F.

		Pro orientovan√© grafy je nutno spoƒç√≠tat jak Tok z vybran√©ho vrcholu do Vi (z mno≈æiny V\{k}) z k tak o obracenƒõ, z Vi do k.

		Tak≈æe pro neorientovan√Ω graf |V| - 1 je max poƒçet spu≈°tƒõn√≠ algoritmu na max tok, pro orientovan√Ω 2(|V| - 1).
	}
11. printf(); Je d√°n neorientovan√Ω graf a ƒç√≠slo k. Zjistƒõte, zda graf je vrcholovƒõ k-souvisl√Ω.
	{
		Tak z vrcholu udƒõl√°m hranu n√°sleduj√≠c√≠m zp≈Øsobem:
		Pro p≈Øvodn√≠ vrchol a p≈ôid√°m 2 vrcholy a1, a2. Kter√© spoj√≠m hranou (a1, a2). Pak je≈°tƒõ spoj√≠m v≈°echny vrcholy, kter√© p≈ôedt√≠m byly spojen√Ω hranou s a: (a, b), s a2. Neboli pro v≈°echny b : (a, b) byla hrana v p≈Øvodn√≠m grafu, vytvo≈ô√≠m hranu (a2, b).

		Pak m≈Ø≈æu pou≈æit algoritmus pro hranovƒõ disjunktn√≠ cesty na modifikovan√Ω graf, proto≈æe vrcholovƒõ disjunktn√≠ cesta je hranov√© disjunktn√≠(viz 8).
	}
5. printf(); Naleznƒõte polynomi√°ln√≠ algoritmus, kter√Ω v dan√©m bipartitn√≠m grafu najde nejmen≈°√≠ vrcholov√© pokryt√≠.
	{
		Veta (K√∂nigova): V ka≈ædom bipartitonom grafe je veƒækos≈• maxim√°lneho p√°rovania rovn√° veƒækosti minim√°lneho vrcholov√©ho pokrytia.

		Teda probl√©m minim√°lneho vrcholov√©ho pokrytia (v bipartitnom grafe) m√¥≈æeme previes≈• na probl√©m maxim√°lneho p√°rovania.

		Veta: Najv√§ƒç≈°√≠ tok odpoved√° najv√§ƒç≈°iemu p√°rovaniu.

		Teda n√°sleduj√∫ci pr√≠klad vyrie≈°ime tak, ≈æe zadan√Ω bipartitn√Ω graf (V,E) pretvor√≠me na sie≈• (V',E',z,s,c) a 
		spust√≠me Ford-Fulkersonov algoritmus.

		Pretvorenie grafu (V,E) na (V',E',z,s,c):
		- N√°jdeme partity grafu: prav√° a ƒæav√°
		- V≈°etky hrany zorientujeme zƒæava doprava
		- Prid√°me zdroj z a vedieme z neho hrany do v≈°etk√Ωch vrcholov ƒæavej partity
		- Prid√°me spotrebiƒç s a vedieme do neho hrany z v≈°etk√Ωch vrcholov pravej partity
		- V≈°etk√Ωm hran√°m nastav√≠me jednotkov√∫ kapacitu

		Teraz v tejto sieti n√°jdeme maxim√°lny celoƒç√≠seln√Ω tok. Keƒè≈æe v≈°etky hrany maj√∫ kapacitu 1, mus√≠ po v≈°etk√Ωch hran√°ch ties≈• buƒè 0 alebo 1.

		Do v√Ωsledn√©ho p√°rovania vlo≈æ√≠me pr√°ve tie hrany p√¥vodn√©ho grafu, po ktor√Ωch teƒçie 1.

		D√¥kaz spr√°vnosti (Najv√§ƒç≈°ie p√°rovanie):
		1. sporom (P√°rovanie):
			Nedostali sme p√°rovanie, teda nejak√© 2 hrany maj√∫ spoloƒçn√Ω vrchol. 
			- Pokiaƒæ z pravej partity: pritiekli 2 jednotky toku, ale nemaj√∫ kam odtiec≈•.
			- Pokiaƒæ z ƒæavej partity: musia odtiec≈• 2 jednotky toku, ale nemaj√∫ kam. (spor)
		2. priamo (Najv√§ƒç≈°ie)
			Z toku vytvor√≠me p√°rovanie o toƒæko hran√°ch, koƒæko je veƒækos≈• toku a naopak, z ka≈æd√©ho p√°rovania vieme vytvori≈• celoƒç√≠seln√Ω tok 
			odpovedaj√∫ci veƒækosti - na≈°li sme bijekciu, ktor√° zachov√°va veƒækos≈•.

		ƒåasov√° zlo≈æitos≈•:

		Veta: Najv√§ƒç≈°ie p√°rovanie v bipartitnom grafe n√°jdeme v ƒçase O(nm). // U tohto m√°m pozn√°mku od Kr√°la: Staƒç√≠ O(n^2)... tok nebude v√§ƒç≈°√≠, ne≈æ n.

		D√¥kaz: Preveden√° kon≈°trukcia: n'= n+2, m' = m+2n (vrcholy, hrany) spotrebuje ƒças O(n'+m'). N√°jdenie max. celoƒç√≠seln√©ho toku Ford-Fulkersnov√Ωm
		algoritmom trv√° O(n'm') - pri jednotliv√Ωch kapacit√°ch - jedna iter√°cia be≈æ√≠ v ƒçase O(m), nenas√Ωten√∫ cestu s BFS, zlep≈°enie toku v line√°rnom ƒçase,
		ka≈æd√° iter√°cia zlep≈°√≠ tok aspo≈à o 1, poƒçet iterac√≠ je obmedzen√° max. toku, teda najviac n. Nakoniec tok v line√°rnom ƒçase prelo≈æ√≠me na p√°rovanie.
		O(n'm') = O(mn). // Copy-paste z Mare≈°ov√Ωch skript.

		Priestorov√° zlo≈æitos≈•:

		Priestor potrebujeme na vrcholy, hrany + zdroj, stok a nov√© hrany: n+2+m+2n = 3n+m+2, teda O(3n+m+2) //kon≈°tanty,
		teda O(n+m).

		D√¥kaz (K√∂nig):
		Pokiaƒæ U podmno≈æinou V je vrcholov√© pokrytie, musia hrany ved√∫ce medzi vrcholami tejto mno≈æiny a zdrojom a stokom tvori≈• rovnak√Ω veƒæk√Ω rez, 
		preto≈æe ka≈æd√° s,t-cesta obsahuje aspo≈à 1 hranu bipartitn√©ho grafu a t√° je pokryt√°. Analogicky vezmeme ƒæubovoln√Ω st-rez, *bez zv√§ƒç≈°enia uprav√≠me
		na st-rez pou≈æ√≠vaj√∫ci iba hrany zo s do t, ktor√© odpovedaj√∫ vrcholov√©mu pokrytiu rovnakej veƒækosti.* // Od 1.* po 2.* podƒçiarknut√© a k tomu pozn√°mka:
		// Ano, d√° se i ≈ô√≠ct, ≈æe kapacity p≈Øvodn√≠ho p√°rov√°n√≠ budou velk√©, pak FF vybere rovnou ten ≈ôez, ktor√Ω chce≈°.
	}

21. scanf("Kyrylo") Jak nal√©zt pr≈Øseƒç√≠ky zadan√Ωch parabol (tvaru ax^2+bx+c pro a>0)? (*) Bez omezen√≠ na a.

#define Rovina
2. scanf("Ivona") Jsou d√°ny mno≈æiny bod≈Ø v rovinƒõ: ƒçerven√© a zelen√©. Sestrojte p≈ô√≠mku takovou, aby na jedn√© jej√≠ stranƒõ le≈æely v≈°echny ƒçerven√© body, zat√≠mco na druh√© v≈°echny zelen√©.
4. scanf("Ivona") Je d√°na mno≈æina bod≈Ø v rovinƒõ. Oplo≈•te ji dvƒõma uzav≈ôen√Ωmi ploty tak, aby celkov√° spot≈ôeba pletiva byla minim√°ln√≠.
9. scanf("Kyrylo") Jsou d√°ny dva mnoho√∫heln√≠ky. Prot√≠naj√≠ se (ne nutnƒõ hranic√≠)?
	{
		
	}
12. scanf("Kyrylo") Navrhnƒõte datovou strukturu, kter√° dostane mno≈æinu obd√©ln√≠k≈Ø v rovinƒõ (v osov√© poloze) a bude umƒõt rychle odpov√≠dat na dotazy typu "v kolika obd√©ln√≠c√≠ch z mno≈æiny se nach√°z√≠ tento bod?".
	{
		
	}

#define Hradla
10. Navrhnƒõte hradlovou s√≠≈•, kter√° testuje, zda se v n-bitov√© posloupnosti vyskytuje nƒõjak√Ω pevn√Ω vzorek. V√Ωstupem nech≈• je ano/ne.

#define Ostatni
6. scanf("Ivona") Definujme permanent matice stejnƒõ jako determinant, ale bez znam√©nkov√©ho pravidla (v≈°echny ƒçleny p≈ôisp√≠vaj√≠ kladnƒõ). Chceme pro danou nula-jedniƒçkovou matici zjistit, zda m√° nenulov√Ω permanent.
13. scanf("Ivona") Uva≈æujme probl√©m "Je d√°na soustava line√°rn√≠ch rovnic v cel√Ωch ƒç√≠slech. Existuje vektor slo≈æen√Ω z nul a jedniƒçek, kter√Ω ji ≈ôe≈°√≠?" Doka≈æte, ≈æe tento probl√©m je NP-√∫pln√Ω.
15. scanf("Ivona") Hled√°n√≠ nejvƒõt≈°√≠ nez√°visl√© mno≈æiny v intervalov√©m grafu (to je graf, jeho≈æ vrcholy jsou intervaly a hrany spojuj√≠ dvojice interval≈Ø maj√≠c√≠ nepr√°zdn√Ω pr≈Ønik).
24. scanf("Kyrylo") Uva≈æujme probl√©m nez√°visl√© mno≈æiny v grafech s maxim√°ln√≠m stupnƒõm 4 resp. 2. Rozhodnƒõte, zda tento probl√©m pat≈ô√≠ do P nebo je NP-√∫pln√Ω.
	{
		Prevedeme na to 3,3-SAT (2 hrany ma kazdy vrchol v trojuhelniku a dale muze byt spojen s nejvyse 2 svymi negacemi, tj. nevytvorime vic nez 4 hrany).
	}
25. scanf("Kyrylo") Jsou d√°ny Fourierovy obrazy dvou vektor≈Ø. Jak podle nich rozhodnout, zda je jeden vektor rotac√≠ druh√©ho?
	{
		
	}

27. Spoƒç√≠tejte diskr√©tn√≠ Fourierovu transformaci vektoru (i,-1,-i,1,i,-1,-i,1).

Teorie
4. scanf("Ivona") Aho-Corasickov√° pro vyhled√°v√°n√≠ v textu.
	{
	- Zobecnenie Knuthova-Morrisova-Prattova algoritmu pre viac re≈•azcov.
		- Op√§≈• zostavenie automatu, ktor√Ω m√° dopredn√© a sp√§tn√© hrany.
		- Po novom zavedieme skratkov√© hrany:
			- Skratkov√° hrana zo stavu Œ≤ vedie do najbli≈æ≈°ieho koncov√©ho stavu h(Œ≤) dosa≈æiteƒæn√©ho z Œ≤ po sp√§tn√Ωch hran√°ch (a 			   r√¥zneho od Œ≤)
			- In√Ωmi slovami, skratka h(Œ≤) n√°m povie, ak√Ω je najdlh≈°√≠ vlastn√Ω suffix slova Œ≤, ktor√Ω je ihlou.

		- Algoritmus: //Zo skr√≠pt
			-AC KROK
				Procedura AcKrok (jeden krok automatu)
				Vstup: Jsme ve stavu s, p≈ôeƒçetli jsme znak x
				1. Dokud Dop≈ôedu(s, x) = ‚àÖ ‚àß s 6= ko≈ôen: s ‚Üê Zpƒõt(s).
				2. Pokud Dop≈ôedu(s, x) 6= ‚àÖ: s ‚Üê Dop≈ôedu(s, x).
				V√Ωstup: Nov√Ω stav s

			-AC HLEDEJ
				Algoritmus AcHledej (spu≈°tƒõn√≠ automatu na dan√Ω ≈ôetƒõzec)
				Vstup: Seno œÉ, zkonstruovan√Ω automat
				1. s ‚Üê ko≈ôen
				2. Pro znaky x ‚àà œÉ postupnƒõ prov√°d√≠me:
				3. s ‚Üê AcKrok(s, x)
				4. j ‚Üê s
				5. Dokud j 6= ‚àÖ:
				6. Je-li Slovo(j) 6= ‚àÖ:
				7. Ohl√°s√≠me Slovo(j).
				8. j ‚Üê Zkratka(j)

			-AC KONSTRUKCE
				Algoritmus AcKonstrukce
				Vstup: Slova Œπ1, . . . , Œπn
				1. Zalo≈æ√≠me strom, kter√Ω obsahuje pouze ko≈ôen r.
				2. Vlo≈æ√≠me do stromu slova Œπ1. . . Œπn, nastav√≠me Slovo ve v≈°ech stavech.
				3. Zpƒõt(r) ‚Üê ‚àÖ, Zkratka(r) ‚Üê ‚àÖ
				4. Zalo≈æ√≠me frontu F a vlo≈æ√≠me do n√≠ syny ko≈ôene.
				5. Pro v≈°echny syny s ko≈ôene: Zpƒõt(s) ‚Üê r, Zkratka(s) ‚Üê ‚àÖ.
				6. Dokud F 6= ‚àÖ:
				7. Vybereme i z fronty F.
				8. Pro v≈°echny syny s vrcholu i:
				9. z ‚Üê AcKrok(Zpƒõt(i), p√≠smeno na hranƒõ is)
				10. Zpƒõt(s) ‚Üê z
				11. Pokud Slovo(z) 6= ‚àÖ: Zkratka(s) ‚Üê z.
				12. Jinak Zkratka(s) ‚Üê Zkratka(z).
				13. Vlo≈æ√≠me s do fronty F.
				V√Ωstup: Strom, pole Slovo, Zpƒõt a Zkratka

		- Algoritmus be≈æ√≠ v ƒçase e Œò ((suma)Ji + S + V)
			- J1,...,Jn s√∫ dƒ∫≈æky jednotliv√Ωch ihiel, S je dƒ∫≈æka sena a V poƒçet v√Ωskytov
	}

2. scanf("Ivona") Rabin≈Øv-Karp≈Øv algoritmus.

10. scanf("Ivona") Algoritmus Knuth-Morris-Pratt.
	{
		- Inkrement√°ln√Ω algoritmus
			- Opiera sa o vyhlad√°vac√≠ automat
			- Vrcholy s√∫ spojen√© hranami dvoch druhov:
				- Dopredn√©: popisuj√∫ roz≈°√≠renie prefixu pridan√≠m jednoho p√≠smena, 
				- Sp√§tn√© ved√∫ podƒæa sp√§tnej funkie (z ka≈æd√©ho stavu do jeho najdlh≈°ieho vlastn√©ho suffixu, ktor√Ω je op√§≈• stavom)
					- Najdlh≈°√≠ prefix ihly, ktor√Ω je suffixom prehƒæad√°van√©ho sena.

			- Algoritmus: //Zo skr√≠pt
				- KMP KROK
					Procedura KmpKrok (jeden krok automatu)
					Vstup: Jsme ve stavu s, p≈ôeƒçetli jsme znak x
					1. Dokud Œπ[s] 6= x ‚àß s 6= 0 : s ‚Üê Z[s]. / zpƒõtn√© hrany
					2. Pokud Œπ[s] = x, pak s ‚Üê s + 1. / dop≈ôedn√° hrana
					V√Ωstup: Nov√Ω stav s

				- KMP HLEDEJ
					Algoritmus KmpHledej (spu≈°tƒõn√≠ automatu na ≈ôetƒõzec œÉ)
						Vstup: Seno œÉ, zkonstruovan√Ω automat
						1. s ‚Üê 0
						2. Pro znaky x ‚àà œÉ postupnƒõ prov√°d√≠me:
						3. s ‚Üê KmpKrok(s, x)
						4. Pokud s = J, ohl√°s√≠me v√Ωskyt.

				- KMP KONSTRUKCE
					Algoritmus KmpKonstrukce
					Vstup: Jehla Œπ d√©lky J
					1. Z[0] ‚Üê nedefinov√°no, Z[1] ‚Üê 0
					2. s ‚Üê 0
					3. Pro i = 2, . . . , J:
					4. s ‚Üê KmpKrok(s, Œπ[i ‚àí 1])
					5. Z[i] ‚Üê s
					V√Ωstup: Pole zpƒõtn√Ωch hran Z

			- Algoritmus be≈æ√≠ v ƒçase O(J+S)
				- Line√°rny ƒças s dƒ∫≈ækou ihly(J) potrebujeme na postavenie automatu, line√°rny ƒças s dƒ∫≈ækou sena potom samotn√© 				  vyhƒæad√°vanie
	}

3. scanf("Ivona") Dinic

1. printf(); Goldberg
	{
		tok Goldberg(){
			//Init
			h(z) = n;
			foreach(vrchol v in V){
				h(v) = 0;
			}
			//Starting first wave
			foreach(hrana h in H){ //All to zero
				if(h ma zdroj jako vrchol) f(h) = c(h);
				else f(h) = 0;
			}
			while(Existuje vrchol u != Z OR S, ≈æe Pritok > 0){
				if (Existuje hrana ua, r(ua)>0 AND h(u) > h(a))
				{
					p≈ôevedeme p≈ôebytek po hranƒõ uv
				}
				else
				{
					u: ++h(u); //zvedneme u:...
				}
			}
			return max. tok f
		}

		Invarian:
		1. f je vlna
		2. h(v) nikdy neklesa
		3. h(Z) = n AND h(S) = 0
		4. prebytek S >= 0

		Dukaz indukci //TODO finish
		n = 0 -> plati
		zmena prebytku -> nevytvari zaporne

		Lemma o korektnost√≠(v returnu je TOK a je max):
			1) vlna splnuje pozadavek na f(v) ‚â§ c(v). Chceme Kirfchhoffuv zakon: Dukaz sporem, kdyby nebyl splnen v nejakem vrcholu v, tak alg se nezastavi.
			2) f je max: Sporem, necht tok neni max -> Existuje nenasycena cesta z Z do S.
				Z ma vysku N, S - 0, takze cesta ma spad N.(ma ale jen (n-1) hran) -> najde se hrana se spadem aspo≈à 2 - je nenasycena, spor s Invariantem S.
		Veta o casove slo≈æitosti(O(n^2*m)):
			1. Init trva O(m);
			2. alg provede nejvys 2n^2 zvednuti(Lemma Z)
			3. nejvyse n*m nasycenych prevedeni
			4. nejvyse n^2*m nenasycenych prevedeni(Lemma N)
			Dohromady O(n^3 + n*m + n^2*m) = O(n^2*m)
	}
14. scanf("Ivona") Ford-Fulkerson

16. scanf("Ivona") Convex hull
6. scanf("Ivona") Definujte Voron√©ho diagram a popi≈°te algoritmus na jeho konstrukci
8. printf(); Pr≈Øseƒç√≠ky √∫seƒçek
	{
		//Princip Zametani Roviny
		P = null; //Prurez
		K[points] += zacatky a konce usecek. //Kalendar
		while(k.empty() != true){
			U = k.pop(); //vyndame posledni udalost
			if(U == zacatek usecky) P += novou usecku;
			if(U == konec usecky) P -= usecku;
			if(U == prusecik){
				printf("Prusecik!"); prohodime usecky v P; //TODO explain this step
			}
			Prepocitame naplanovane prusecikove udalosti v okoli zmeny(nejv√Ω≈°e dvƒõ odebereme a dvƒõ nov√© p≈ôid√°me);
		}

		//Analysis of Time complexity
		Kalendar - halda nebo vyhled. strom, v≈ædy ma 3n udalosti O(log(n))
		Vlo≈æ√≠me do vyhled stromu odkazy na usecky O(log(n))
		Pro kazdou udalost O(1) operace s Datovymi struktury
		Vsech n+p udalosti zpracujeme za O(log(n)*(n+p))
	}
7. scanf("Kyrylo") Rychl√° Fourierova transformace
	{
		polynom_nasobeni(polynom Q, polynom P, deg N)
		{
			//Init
			Doplnime Q a P na 2*N (pokud deg(P) = deg(Q) = N)
			//Zvolme navzajem ruzna W0, W1 ... W2n-1
			Zvolime primitivni odmocninu 1 = W;
			F[] = FFT(2*N, P, W);
			G[] = FFT(2*N, Q, m);
			for(int i = 0; i < 2*N; ++i)
				R[i] = F[i]*G[i];

			FFT^(-1)(R[]); //TODO
		}

		vektor FFT(deg n, mocnina W, vektor P)
		{
			if(n == 1) Y0 = P0; return Y;

			(S0, ... Sn) = FFT (n/2, W^2, P sude);
			(L0, ... Ln) = FFT (n/2, W^2, P liche);

			for(int j = 0; j < n; ++j){
				Y[j] = S[j] + W[j] * L[j];
				Y[j+n] = S[j] - W[j] * L[j];
			}
			return Y;
		}

		//Casova slozitost
		Je-li N = 2^k, pak v O(n*log(n)) lze spocitat FFT a FFT^(-1) v C^n. Nasobeni polynomu v O(n*log(n))

		funkce FFT trva (n*log(n)), nasobeni O(n).
	}

11. printf(); NP-√∫plnost: definice t≈ô√≠d, Cookova vƒõta, d≈Økaz NP-√∫plnosti vybran√©ho probl√©mu
	{
		case P: Trida P rozhodovacich problemu (jsou resitelne v polynomi√°ln√≠m ƒçase).
		L ‚àà P <-> Existuje nejaky alg. A a polynom f, pro kazdy vstup X alg A dovehne v caaw nejvyse f(|X|) a vyda vysledek A(X) = L(X)

		case NP: Trida NP, L ‚àà NP <-> Existuje nejaky problem k ‚àà P a polynom g,
		pro vsechna X je L(X) = 1 prave tehdy, pokud pro nejaky retezec y delkz nejvyse g(|x|) plati k(x,y);
		//Existuje polynomialni dlouha napoveda y. Je-li L(X) = 1, musi existovat aspon 1 napoveda, kterou alg k schvali.

		case NP-tezky: problem L je NP-tezky <-> na nej je predvoditelny kazdy problem z NP.
		case NP-√∫plnost: Problem je NP-√∫plny kdy≈æ je NP-tezky a zaroven lezi v NP.
		case Cook theorem: SAT je NP-uplny problem.
	}
13. scanf("Kyrylo") Probl√©m batohu ‚Äì pseudopolynomi√°ln√≠ algoritmus a aproximaƒçn√≠ sch√©ma
	{
		foreach(predmet P in batohu) if(vaha P > const H) batohu.remove(P);
		Cmax = max Ci;
		M = Horni_cela_cast(n/e);
		for(int i = 0; i < n+1; ++i)
			Cnew[i] = dolni_cela_cast(C[i] * M/Cmax);
		Vy≈ôe≈°√≠me dynamick√Ωm programov√°n√≠m probl√©m batohu pro upraven√© ceny Cnew a p≈Øvodn√≠ hmotnosti i kapacitu batohu.
		Vybereme stejn√© p≈ôedmƒõty, jak√© pou≈æilo optim√°ln√≠ ≈ôe≈°en√≠ kvantovan√©ho zad√°n√≠.

		//Casova Slozitost
		Kroky 1‚Äì3 a 5 jistƒõ zvl√°dneme v ƒçase ùí™(n).
		Krok 4 ≈ôe≈°√≠ probl√©m batohu se souƒçtem cen ƒà ‚â§ nM = ùí™(n2/Œµ), co≈æ stihne v ƒçase ùí™(nƒà) = ùí™(n3/Œµ).
		Zb√Ωv√° dok√°zat, ≈æe v√Ωsledek na≈°eho algoritmu m√° opravdu relativn√≠ chybu nejv√Ω≈°e Œµ. //TODO
	}
5. printf(); 2-aproximace probl√©mu obchodn√≠ho cestuj√≠c√≠ho
	{
		//Nejkratsi z Hamiltonovskych kruznic v grafu s ohodnocenim
		if(Graf je uplny ^ plati v nem trojuhelnikova nerovnost) muzeme 2-aproximovat;
		//To znamen√° naj√≠t v polynomi√°ln√≠m ƒçase kru≈ænici,
		//kter√° je p≈ôinejhor≈°√≠m dvakr√°t del≈°√≠ ne≈æ ta optim√°ln√≠.

		1. Najdeme Kostru
		2. Zakoreneme naleznutou kostru
		3. Pustime DFS a poznamename v jakem poradi jsme nalezli hrany
		4. Kazdou hranu projdeme 2krat (dolu a nahoru). Upravime tento sled tak, ze kdykoliv se dost√°v√° do ji≈æ nav≈°t√≠ven√©ho vrcholu,
		p≈ôeskoƒç√≠ ho a p≈ôesune se a≈æ do nejbli≈æ≈°√≠ho dal≈°√≠ho nenav≈°t√≠ven√©ho.
		Tak ze sledu vytvo≈ô√≠me hamiltonovskou kru≈ænici a jeliko≈æ v grafu plat√≠ troj√∫heln√≠kov√° nerovnost, celkov√° d√©lka nevzrostla.

		Vƒõta: Nalezen√° kru≈ænice nen√≠ del≈°√≠ ne≈æ dvojn√°sobek optima
		T je delka min Kostry. A delka kruznice v 2-apr alg., O - optimalni hamiltonovska kruznice
		A ‚â§ 2*T
		T ‚â§ O //jeliko≈æ z ka≈æd√© hamiltonovsk√© kru≈ænice vznikne vynech√°n√≠m hrany kostra a ta nem≈Ø≈æe b√Ωt krat≈°√≠ ne≈æ minim√°ln√≠

		A ‚â§ 2*T ‚â§ 2*O
	}

15. scanf("Kyrylo") binary addition
	{
		
	}
12. scanf("Kyrylo") Hradlov√° s√≠≈•, kter√° o dvojici bin√°rn√≠ch ƒç√≠sel zjist√≠, zda je prvn√≠ vƒõt≈°√≠ ne≈æ druh√©.
	{
		
	}