ADS II prakticke
#define Text

1. printf() NajdÄ›te pro danÃ½ Å™etÄ›zec co nejdelÅ¡Ã­ podÅ™etÄ›zec, kterÃ½ je souÄasnÄ› prefixem i suffixem (vlastnÃ­m).
	{
		viz 20. PrefixFunction()
	}
14. scanf("Ivona") NÃ¡hrdelnÃ­k je cyklickÃ½ Å™etÄ›zec, kterÃ½ nemÃ¡ urÄenÃ½ ani zaÄÃ¡tek, ani smÄ›r ÄtenÃ­. Jak rozhodnout, zda jsou si dva nÃ¡hrdelnÃ­ky rovny?

7. scanf("Ivona") V danÃ©m Å™etÄ›zci nad abecedou {a,b} chceme nalÃ©zt nejdelÅ¡Ã­ Fibonacciho podslovo.
Fibonacciho slova jsou definovÃ¡na takto: F1=a, F2=b, Fn+2=FnFn+1.
	{
		//TODO https://cstheory.stackexchange.com/questions/29323/fibonacci-words/29327
	}
16. scanf("Kyrylo") Je dÃ¡n slovnÃ­k a text. NavrhnÄ›te algoritmus, kterÃ½ pro kaÅ¾dÃ© slovo ze slovnÃ­ku spoÄte, kolikrÃ¡t se v textu vyskytuje jako podÅ™etÄ›zec.
20. printf() Jak zjistit, jestli je zadanÃ½ Å™etÄ›zec periodickÃ½? Tedy zda pro danÃ½ Å™etÄ›zec Î± existuje Å™etÄ›zec Î² a ÄÃ­slo k>1 tak, Å¾e Î± = Î²k.
	{
		Tak druhÃ½ pokus. Pomoci KMP najdu nejdelÅ¡Ã­ Sufix, kterÃ½ je zÃ¡roveÅˆ Prefixem slova (budou mÄ› zajÃ­mat âˆ€ takovÃ© kromÄ› triviÃ¡lnÃ­ho pÅ™Ã­padu, kdyÅ¾ prefix = sufix = celÃ© slovo).
		Pak pokud takovÃ½ existuje, jeho dÃ©lka je K a N se dÄ›lÃ­ beze zbytku (N - K), tak slovo je periodickÃ©.

	Pro vÃ½poÄet dÃ©lky takovÃ©ho sufixu/prefixu pouÅ¾ijÃ­ nÃ¡sledujÃ­cÃ­ funkce. KterÃ¡ spoÄÃ­tÃ¡ tzv. prefixovou funkci KMP.

	void PrefixFunction(string str)
	{
	    int longest_prefix[str.length];
	    int length = 0; //ZatÃ­m nejdelÅ¡Ã­ suffix
	    int i;
	 
	    longest_prefix[0] = 0;
	    i = 1;

	    while (i < str.length)
	    {
	       if (str[i] == str[length])
	       {
	           ++length;
	           longest_prefix[i] = length;
	           ++i;
	       }
	       else
	       {
	          if (length != 0)
	          {
	             length = longest_prefix[length-1];
	          }
	          else // if (length == 0)
	          {
	             longest_prefix[i] = 0;
	             ++i;
	          }
	       }
	    }
	}

	Z toho pole vezmu poslednÃ­ prvek(longest_prefix[longest_prefix.Length - 1]), coÅ¾ je dÃ©lka hledanÃ©ho sufixu/prefixu K.

	JelikoÅ¾ tento algoritmus je KMP a jedno porovnanÃ­ navÃ­c, ÄasovÃ¡ sloÅ¾itost je O(N);
	}
26. scanf("Kyrylo") Je dÃ¡n text a ÄÃ­slo K. NaleznÄ›te podÅ™etÄ›zec dÃ©lky K, kterÃ½ se v textu vyskytuje nejÄastÄ›ji.
22. scanf("Kyrylo") Je dÃ¡n Å™etÄ›zec a ÄÃ­slo K. KterÃ½ podÅ™etÄ›zec dÃ©lky K je nejÄetnÄ›jÅ¡Ã­?
27. printf() Zjistit jestli slovo A je rotaci B
	{
		vezmeme B dvakrat(tento retezec bude obsahovat vsechny rotace B). Udelame automat z A, spustime KMP.
	}

#undef Text

#define Toky
3. scanf("Ivona") MÄ›jme dÄ›ravou Å¡achnovnici. Jak ji pokrÃ½t kostkami 1Ã—2 polÃ­Äka?

17. scanf("Ivona") MÄ›jme strom, jehoÅ¾ vrcholy jsou opatÅ™eny celoÄÃ­selnÃ½mi vahami.
Chceme nalÃ©zt nezÃ¡vislou mnoÅ¾inu, jejÃ­Å¾ souÄet vah je nejvÄ›tÅ¡Ã­ moÅ¾nÃ½.
	{
		//TODO https://www.coursera.org/learn/advanced-algorithms-and-complexity/lecture/bXeiI/independent-sets-in-trees
		//http://hscc.cs.nthu.edu.tw/~sheujp/public/journal/3.pdf
	}
18. printf() Zjistit, jak rychle bÄ›Å¾Ã­ GoldbergÅ¯v algoritmus na sÃ­ti s jednotkovÃ½mi kapacitami
	{
		Ty jednotkove kapacity zaridi, ze nemame nenasycena prevedeni. To by nam zbyvala slozitost O(N^3 + NM). Jde to ale i na O(NM), kdyz si trosku vylepsime odhad poctu zvednuti.
		Diky implementaci nas jedno zvednuti stoji â‰¤ N. Kazda hrana ma dva vrcholy a kolikrat muzeme zvednout vrchol, uz vime, ze?
		Takze pro kazdou hranu mame â‰¤ 4N zvednuti, tedy cas na zvedani taky O(NM).
		MJ mi rikal jeste jinou verzi dukazu O(NM) zvednuti, a to pres scitani vstupnich a vystupnich stupnu vrcholu - nicmene uvedeny postup je taky spravny.
	}
19. printf() Je dÃ¡n orientovanÃ½ graf a jeho vrcholy u, v. Chceme nalÃ©zt co nejvÃ­ce hranovÄ› disjunktnÃ­ch cest z u do v.
	Za zdroj si vezmu U jako zdroj a V jako stok. KaÅ¾dÃ© hranÄ› pÅ™iÅ™adÃ­m kapacitu 1, v pÅ™Ã­padÄ› vrcholovÄ› z disjunktnÃ­ch cest jeÅ¡tÄ› vrcholÅ¯m kapacitu 1.
	PustÃ­m na tento graf napÅ™ F-F algoritmus. UvÃ¡Å¾Ã­m ty hrany, kterÃ½m algoritmus pÅ™iÅ™adÃ­ tok 1. ZbÃ½vÃ¡ jeÅ¡tÄ› Å™eÅ¡it pÅ™Ã­pad kdyÅ¾ cesta obsahuje cyklus.
	StaÄÃ­ projÃ­t graf a pokud nÄ›jakÃ½ vrchol potkÃ¡m dvakrÃ¡t, tak je tam cyklus, kterÃ½ musÃ­m smazat. KdyÅ¾ smaÅ¾u cyklus tak dostanu cestu od U do V.
	Naleznutou cestu smaÅ¾u, v hledanÃ­ cest budu pokraÄovat pokud Tok nenÃ­ nulovÃ½.

	ÄasovÃ¡ sloÅ¾itost: F-F O(m*n), jelikoÅ¾ cesty jsou disjunktnÃ­ jejÃ­ch hledanÃ­ po ukonÄenÃ­ F-F je O(m). TakÅ¾e O(m*n) dohromady.

	//Vrcholove
	Tak z vrcholu udÄ›lÃ¡m hranu nÃ¡sledujÃ­cÃ­m zpÅ¯sobem:
	Pro pÅ¯vodnÃ­ vrchol a pÅ™idÃ¡m 2 vrcholy a1, a2. KterÃ© spojÃ­m hranou (a1, a2). Pak jeÅ¡tÄ› spojÃ­m vÅ¡echny vrcholy, kterÃ© pÅ™edtÃ­m byly spojenÃ½ hranou s a: (a, b), s a2. Neboli pro vÅ¡echny b : (a, b) byla hrana v pÅ¯vodnÃ­m grafu, vytvoÅ™Ã­m hranu (a2, b).

	Pak mÅ¯Å¾u pouÅ¾it algoritmus pro hranovÄ› disjunktnÃ­ cesty na modifikovanÃ½ graf, protoÅ¾e vrcholovÄ› disjunktnÃ­ cesta je hranovÃ© disjunktnÃ­.
8. printf() Pro danÃ½ neorientovanÃ½ graf chceme nalÃ©zt nejvÄ›tÅ¡Ã­ k takovÃ©, Å¾e graf je hranovÄ› k-souvislÃ½.
	{
		KdyÅ¾ budu spouÅ¡tÄ›t algoritmus na hledanÃ­ max toku na vÅ¡echny dvojice vrcholu, tak urÄitÄ› vÅ¡echny hranovÄ› disjunktnÃ­ cesty potkÃ¡m nÄ›kolikrÃ¡t.
		TakÅ¾e staÄÃ­ zafixovat nÄ›jakÃ½ vrchol(tÅ™eba k), oznaÄit ho za Zdroj. Za Stock budu postupnÄ› oznaÄovat vrcholy z V\{k}(Je moÅ¾nÃ© taky neuvaÅ¾ovat sousedy k). Minimum z toku se bude rovnat hranovÃ© souvislosti grafu. ZastavÃ­m se, kdyÅ¾ poÄet iteraci(I) pÅ™esÃ¡hne zatÃ­m minimÃ¡lnÃ­ tok(ProtoÅ¾e hranovÃ¡ souvislost je omezenÃ¡ min stupnÄ›m vrcholu a 2|E|/|V|)

		DÅ¯kaz korektnostÃ­: MinimÃ¡lnÃ­ tok ze vÅ¡ech iteraci oznaÄÃ­m za F.
		Z MengerovÃ© vÄ›ty existuje Separator (mnoÅ¾ina hran, po odebranÃ­ kterÃ½ch graf stane nesouvislÃ½). Velikost separÃ¡toru se rovna souvislostÃ­ grafu(OznaÄÃ­m za R) . AspoÅˆ jeden z mnoÅ¾iny vrcholu V1, V2, ... V(r+1), kde r+1 index, nenÃ­ v tom Å™ezu-separÃ¡toru. NechÅ¥ to bude vrchol Vj. Existuje vrchol Vt z separÃ¡toru takovÃ½, Å¾e #hranovÄ›-disjunktnÃ­ch cest z Vt do Vj = R.

		F >= R,
		I > F
		I >= R + 1

		Z toho C = F.

		Pro orientovanÃ© grafy je nutno spoÄÃ­tat jak Tok z vybranÃ©ho vrcholu do Vi (z mnoÅ¾iny V\{k}) z k tak o obracenÄ›, z Vi do k.

		TakÅ¾e pro neorientovanÃ½ graf |V| - 1 je max poÄet spuÅ¡tÄ›nÃ­ algoritmu na max tok, pro orientovanÃ½ 2(|V| - 1).
	}
11. printf() Je dÃ¡n neorientovanÃ½ graf a ÄÃ­slo k. ZjistÄ›te, zda graf je vrcholovÄ› k-souvislÃ½.
	{
		Tak z vrcholu udÄ›lÃ¡m hranu nÃ¡sledujÃ­cÃ­m zpÅ¯sobem:
		Pro pÅ¯vodnÃ­ vrchol a pÅ™idÃ¡m 2 vrcholy a1, a2. KterÃ© spojÃ­m hranou (a1, a2). Pak jeÅ¡tÄ› spojÃ­m vÅ¡echny vrcholy, kterÃ© pÅ™edtÃ­m byly spojenÃ½ hranou s a: (a, b), s a2. Neboli pro vÅ¡echny b : (a, b) byla hrana v pÅ¯vodnÃ­m grafu, vytvoÅ™Ã­m hranu (a2, b).

		Pak mÅ¯Å¾u pouÅ¾it algoritmus pro hranovÄ› disjunktnÃ­ cesty na modifikovanÃ½ graf, protoÅ¾e vrcholovÄ› disjunktnÃ­ cesta je hranovÃ© disjunktnÃ­(viz 8).
	}
5. printf() NaleznÄ›te polynomiÃ¡lnÃ­ algoritmus, kterÃ½ v danÃ©m bipartitnÃ­m grafu najde nejmenÅ¡Ã­ vrcholovÃ© pokrytÃ­.
	{
		Veta (KÃ¶nigova): V kaÅ¾dom bipartitonom grafe je veÄ¾kosÅ¥ maximÃ¡lneho pÃ¡rovania rovnÃ¡ veÄ¾kosti minimÃ¡lneho vrcholovÃ©ho pokrytia.

		Teda problÃ©m minimÃ¡lneho vrcholovÃ©ho pokrytia (v bipartitnom grafe) mÃ´Å¾eme previesÅ¥ na problÃ©m maximÃ¡lneho pÃ¡rovania.

		Veta: NajvÃ¤ÄÅ¡Ã­ tok odpovedÃ¡ najvÃ¤ÄÅ¡iemu pÃ¡rovaniu.

		Teda nÃ¡sledujÃºci prÃ­klad vyrieÅ¡ime tak, Å¾e zadanÃ½ bipartitnÃ½ graf (V,E) pretvorÃ­me na sieÅ¥ (V',E',z,s,c) a 
		spustÃ­me Ford-Fulkersonov algoritmus.

		Pretvorenie grafu (V,E) na (V',E',z,s,c):
		- NÃ¡jdeme partity grafu: pravÃ¡ a Ä¾avÃ¡
		- VÅ¡etky hrany zorientujeme zÄ¾ava doprava
		- PridÃ¡me zdroj z a vedieme z neho hrany do vÅ¡etkÃ½ch vrcholov Ä¾avej partity
		- PridÃ¡me spotrebiÄ s a vedieme do neho hrany z vÅ¡etkÃ½ch vrcholov pravej partity
		- VÅ¡etkÃ½m hranÃ¡m nastavÃ­me jednotkovÃº kapacitu

		Teraz v tejto sieti nÃ¡jdeme maximÃ¡lny celoÄÃ­selnÃ½ tok. KeÄÅ¾e vÅ¡etky hrany majÃº kapacitu 1, musÃ­ po vÅ¡etkÃ½ch hranÃ¡ch tiesÅ¥ buÄ 0 alebo 1.

		Do vÃ½slednÃ©ho pÃ¡rovania vloÅ¾Ã­me prÃ¡ve tie hrany pÃ´vodnÃ©ho grafu, po ktorÃ½ch teÄie 1.

		DÃ´kaz sprÃ¡vnosti (NajvÃ¤ÄÅ¡ie pÃ¡rovanie):
		1. sporom (PÃ¡rovanie):
			Nedostali sme pÃ¡rovanie, teda nejakÃ© 2 hrany majÃº spoloÄnÃ½ vrchol. 
			- PokiaÄ¾ z pravej partity: pritiekli 2 jednotky toku, ale nemajÃº kam odtiecÅ¥.
			- PokiaÄ¾ z Ä¾avej partity: musia odtiecÅ¥ 2 jednotky toku, ale nemajÃº kam. (spor)
		2. priamo (NajvÃ¤ÄÅ¡ie)
			Z toku vytvorÃ­me pÃ¡rovanie o toÄ¾ko hranÃ¡ch, koÄ¾ko je veÄ¾kosÅ¥ toku a naopak, z kaÅ¾dÃ©ho pÃ¡rovania vieme vytvoriÅ¥ celoÄÃ­selnÃ½ tok 
			odpovedajÃºci veÄ¾kosti - naÅ¡li sme bijekciu, ktorÃ¡ zachovÃ¡va veÄ¾kosÅ¥.

		ÄŒasovÃ¡ zloÅ¾itosÅ¥:

		Veta: NajvÃ¤ÄÅ¡ie pÃ¡rovanie v bipartitnom grafe nÃ¡jdeme v Äase O(nm). // U tohto mÃ¡m poznÃ¡mku od KrÃ¡la: StaÄÃ­ O(n^2)... tok nebude vÃ¤ÄÅ¡Ã­, neÅ¾ n.

		DÃ´kaz: PrevedenÃ¡ konÅ¡trukcia: n'= n+2, m' = m+2n (vrcholy, hrany) spotrebuje Äas O(n'+m'). NÃ¡jdenie max. celoÄÃ­selnÃ©ho toku Ford-FulkersnovÃ½m
		algoritmom trvÃ¡ O(n'm') - pri jednotlivÃ½ch kapacitÃ¡ch - jedna iterÃ¡cia beÅ¾Ã­ v Äase O(m), nenasÃ½tenÃº cestu s BFS, zlepÅ¡enie toku v lineÃ¡rnom Äase,
		kaÅ¾dÃ¡ iterÃ¡cia zlepÅ¡Ã­ tok aspoÅˆ o 1, poÄet iteracÃ­ je obmedzenÃ¡ max. toku, teda najviac n. Nakoniec tok v lineÃ¡rnom Äase preloÅ¾Ã­me na pÃ¡rovanie.
		O(n'm') = O(mn). // Copy-paste z MareÅ¡ovÃ½ch skript.

		PriestorovÃ¡ zloÅ¾itosÅ¥:

		Priestor potrebujeme na vrcholy, hrany + zdroj, stok a novÃ© hrany: n+2+m+2n = 3n+m+2, teda O(3n+m+2) //konÅ¡tanty,
		teda O(n+m).

		DÃ´kaz (KÃ¶nig):
		PokiaÄ¾ U podmnoÅ¾inou V je vrcholovÃ© pokrytie, musia hrany vedÃºce medzi vrcholami tejto mnoÅ¾iny a zdrojom a stokom tvoriÅ¥ rovnakÃ½ veÄ¾kÃ½ rez, 
		pretoÅ¾e kaÅ¾dÃ¡ s,t-cesta obsahuje aspoÅˆ 1 hranu bipartitnÃ©ho grafu a tÃ¡ je pokrytÃ¡. Analogicky vezmeme Ä¾ubovolnÃ½ st-rez, *bez zvÃ¤ÄÅ¡enia upravÃ­me
		na st-rez pouÅ¾Ã­vajÃºci iba hrany zo s do t, ktorÃ© odpovedajÃº vrcholovÃ©mu pokrytiu rovnakej veÄ¾kosti.* // Od 1.* po 2.* podÄiarknutÃ© a k tomu poznÃ¡mka:
		// Ano, dÃ¡ se i Å™Ã­ct, Å¾e kapacity pÅ¯vodnÃ­ho pÃ¡rovÃ¡nÃ­ budou velkÃ©, pak FF vybere rovnou ten Å™ez, ktorÃ½ chceÅ¡.
	}

21. scanf("Kyrylo") Jak nalÃ©zt prÅ¯seÄÃ­ky zadanÃ½ch parabol (tvaru ax^2+bx+c pro a>0)? (*) Bez omezenÃ­ na a.

#undef Toky

#define Rovina
2. scanf("Ivona") Jsou dÃ¡ny mnoÅ¾iny bodÅ¯ v rovinÄ›: ÄervenÃ© a zelenÃ©.
Sestrojte pÅ™Ã­mku takovou, aby na jednÃ© jejÃ­ stranÄ› leÅ¾ely vÅ¡echny ÄervenÃ© body, zatÃ­mco na druhÃ© vÅ¡echny zelenÃ©.
4. scanf("Ivona") Je dÃ¡na mnoÅ¾ina bodÅ¯ v rovinÄ›. OploÅ¥te ji dvÄ›ma uzavÅ™enÃ½mi ploty tak, aby celkovÃ¡ spotÅ™eba pletiva byla minimÃ¡lnÃ­.
9. scanf("Kyrylo") Jsou dÃ¡ny dva mnohoÃºhelnÃ­ky. ProtÃ­najÃ­ se (ne nutnÄ› hranicÃ­)?
	{
		
	}
12. scanf("Kyrylo") NavrhnÄ›te datovou strukturu, kterÃ¡ dostane mnoÅ¾inu obdÃ©lnÃ­kÅ¯ v rovinÄ› (v osovÃ© poloze)
a bude umÄ›t rychle odpovÃ­dat na dotazy typu "v kolika obdÃ©lnÃ­cÃ­ch z mnoÅ¾iny se nachÃ¡zÃ­ tento bod?".
	{
		
	}

#undef Rovina

#define Hradla
10. NavrhnÄ›te hradlovou sÃ­Å¥, kterÃ¡ testuje, zda se v n-bitovÃ© posloupnosti vyskytuje nÄ›jakÃ½ pevnÃ½ vzorek. VÃ½stupem nechÅ¥ je ano/ne.

#undef Hradla

#define Ostatni
6. scanf("Ivona") Definujme permanent matice stejnÄ› jako determinant, ale bez znamÃ©nkovÃ©ho pravidla (vÅ¡echny Äleny pÅ™ispÃ­vajÃ­ kladnÄ›).
Chceme pro danou nula-jedniÄkovou matici zjistit, zda mÃ¡ nenulovÃ½ permanent.
13. scanf("Ivona") UvaÅ¾ujme problÃ©m "Je dÃ¡na soustava lineÃ¡rnÃ­ch rovnic v celÃ½ch ÄÃ­slech. Existuje vektor sloÅ¾enÃ½ z nul a jedniÄek, kterÃ½ ji Å™eÅ¡Ã­?"
DokaÅ¾te, Å¾e tento problÃ©m je NP-ÃºplnÃ½
	{
		1. Problem je v NP. Napoveda - ohodnoceni promennych, linearne overit reseni.
		2. Lze prevest na nejaky z NP-uplnych
		//TODO binarni promenne, prevest na SAT???
	}
15. scanf("Ivona") HledÃ¡nÃ­ nejvÄ›tÅ¡Ã­ nezÃ¡vislÃ© mnoÅ¾iny v intervalovÃ©m grafu
	{
		GREEDY-ALGO
		Step 1:
		Sort the intervals of I according to their right end-points.
		Step 2:
		Find the interval i, whose right end-point is left-most. Include i in the solution set MIS.
		Step 3:
		Remove all intervals of set I which are overlapping with i.
		Step 4:
		Repeat Step 2 & 3 until I is not empty.
		Step 5:
		Report MIS.
		//vic tu http://drona.csa.iisc.ac.in/~minati/archive/mis_CCCG.pdf
	}
24. scanf("Kyrylo") UvaÅ¾ujme problÃ©m nezÃ¡vislÃ© mnoÅ¾iny v grafech s maximÃ¡lnÃ­m stupnÄ›m 4 resp. 2. RozhodnÄ›te, zda tento problÃ©m patÅ™Ã­ do P nebo je NP-ÃºplnÃ½.
	{
		Prevedeme na to 3,3-SAT (2 hrany ma kazdy vrchol v trojuhelniku a dale muze byt spojen s nejvyse 2 svymi negacemi, tj. nevytvorime vic nez 4 hrany).
	}
25. scanf("Kyrylo") Jsou dÃ¡ny Fourierovy obrazy dvou vektorÅ¯. Jak podle nich rozhodnout, zda je jeden vektor rotacÃ­ druhÃ©ho?
	{
		
	}

27. SpoÄÃ­tejte diskrÃ©tnÃ­ Fourierovu transformaci vektoru (i,-1,-i,1,i,-1,-i,1).

#undef Ostatni

Teorie
4. printf() Aho-CorasickovÃ¡ pro vyhledÃ¡vÃ¡nÃ­ v textu
	{
	- Zobecnenie Knuthova-Morrisova-Prattova algoritmu pre viac reÅ¥azcov.
		- OpÃ¤Å¥ zostavenie automatu, ktorÃ½ mÃ¡ doprednÃ© a spÃ¤tnÃ© hrany.
		- Po novom zavedieme skratkovÃ© hrany:
			- SkratkovÃ¡ hrana zo stavu Î² vedie do najbliÅ¾Å¡ieho koncovÃ©ho stavu h(Î²) dosaÅ¾iteÄ¾nÃ©ho z Î² po spÃ¤tnÃ½ch hranÃ¡ch (a rÃ´zneho od Î²)
			- InÃ½mi slovami, skratka h(Î²) nÃ¡m povie, akÃ½ je najdlhÅ¡Ã­ vlastnÃ½ suffix slova Î², ktorÃ½ je ihlou.

		- Algoritmus: //Zo skrÃ­pt
			-AC KROK
				Procedura AcKrok (jeden krok automatu)
				Vstup: Jsme ve stavu s, pÅ™eÄetli jsme znak x
				1. Dokud DopÅ™edu(s, x) = âˆ… âˆ§ s 6= koÅ™en: s = ZpÄ›t(s).
				2. Pokud DopÅ™edu(s, x) 6= âˆ…: s = DopÅ™edu(s, x).
				VÃ½stup: NovÃ½ stav s

			-AC HLEDEJ
				Algoritmus AcHledej (spuÅ¡tÄ›nÃ­ automatu na danÃ½ Å™etÄ›zec)
				Vstup: Seno Ïƒ, zkonstruovanÃ½ automat
				1. s = koÅ™en
				2. Pro znaky x âˆˆ Ïƒ postupnÄ› provÃ¡dÃ­me:
				3. s = AcKrok(s, x)
				4. j = s
				5. Dokud j 6= âˆ…:
				6. Je-li Slovo(j) 6= âˆ…:
				7. OhlÃ¡sÃ­me Slovo(j).
				8. j = Zkratka(j)

			-AC KONSTRUKCE
				Algoritmus AcKonstrukce
				Vstup: Slova Î¹1, . . . , Î¹n
				1. ZaloÅ¾Ã­me strom, kterÃ½ obsahuje pouze koÅ™en r.
				2. VloÅ¾Ã­me do stromu slova Î¹1. . . Î¹n, nastavÃ­me Slovo ve vÅ¡ech stavech.
				3. ZpÄ›t(r) = âˆ…, Zkratka(r) = âˆ…
				4. ZaloÅ¾Ã­me frontu F a vloÅ¾Ã­me do nÃ­ syny koÅ™ene.
				5. Pro vÅ¡echny syny s koÅ™ene: ZpÄ›t(s) = r, Zkratka(s) = âˆ….
				6. Dokud F 6= âˆ…:
				7. Vybereme i z fronty F.
				8. Pro vÅ¡echny syny s vrcholu i:
				9. z = AcKrok(ZpÄ›t(i), pÃ­smeno na hranÄ› is)
				10. ZpÄ›t(s) = z
				11. Pokud Slovo(z) 6= âˆ…: Zkratka(s) = z.
				12. Jinak Zkratka(s) = Zkratka(z).
				13. VloÅ¾Ã­me s do fronty F.
				VÃ½stup: Strom, pole Slovo, ZpÄ›t a Zkratka

		- Algoritmus beÅ¾Ã­ v Äase e Î˜ ((suma)Ji + S + V)
			- J1,...,Jn sÃº dÄºÅ¾ky jednotlivÃ½ch ihiel, S je dÄºÅ¾ka sena a V poÄet vÃ½skytov
	}

2. printf() RabinÅ¯v-KarpÅ¯v algoritmus
	{
		Okenko delky J na senÄ›, spoÄteme Hash a porovnÃ¡me s hashem J.
		if(hash(i) == hash(J)) porovnÃ¡me znak po znaku;

		hash(X[j]) = (X[1]*P^(J-1) + X[2]*P^(J-2) ... X[J-1] * P^1 + X[J]*P) mod(N);
		//P je vhodna const, nesoudelna s N, P^J je Å™adovÄ› vÄ›tÅ¡Ã­ neÅ¾ N

		R-Karp(jehla j delky D, seno Ïƒ)
		{
			S = |Ïƒ|;
			L = hash(j);
			h = H(Ïƒ[:D]); //hash 1. pozice okenka
			//Zvolme P a N, prepocitame (P^J) mod(N)

			for(int i = 0; i â‰¤ S - D; ++i){
				if(h = l){

				}
				if(i < S - D) h = (p*h - Ïƒ[i] * P^J + Ïƒ[i + J]) mod(N); //prepocitame hash
			}
		}

		//Slozitost
		Init a pocitani hash O(J + D). PÅ™i nejhorÅ¡Ã­m O(J) porovnÃ¡vÃ¡nÃ­ pro âˆ€ okÃ©nka.
		pÅ™edpoklad dokonale chovanÃ­ hashe -> P(kolize) = 1/N
		v prÅ¯mÄ›ru O(J + D + V*J + D*J/N) kde V je # vysktytu
		if(N > D*J) -> O(J + D);
	}

10. printf() Algoritmus Knuth-Morris-Pratt
	{
		- InkrementÃ¡lnÃ½ algoritmus
			- Opiera sa o vyhladÃ¡vacÃ­ automat
			- Vrcholy sÃº spojenÃ© hranami dvoch druhov:
				- DoprednÃ©: popisujÃº rozÅ¡Ã­renie prefixu pridanÃ­m jednoho pÃ­smena, 
				- SpÃ¤tnÃ© vedÃº podÄ¾a spÃ¤tnej funkie (z kaÅ¾dÃ©ho stavu do jeho najdlhÅ¡ieho vlastnÃ©ho suffixu, ktorÃ½ je opÃ¤Å¥ stavom)
					- NajdlhÅ¡Ã­ prefix ihly, ktorÃ½ je suffixom prehÄ¾adÃ¡vanÃ©ho sena.

			- Algoritmus: //Zo skrÃ­pt
				- KMP KROK
					Procedura KmpKrok (jeden krok automatu)
					Vstup: Jsme ve stavu s, pÅ™eÄetli jsme znak x
					1. Dokud Î¹[s] 6= x âˆ§ s 6= 0 : s = Z[s]. / zpÄ›tnÃ© hrany
					2. Pokud Î¹[s] = x, pak s = s + 1. / dopÅ™ednÃ¡ hrana
					VÃ½stup: NovÃ½ stav s

				- KMP HLEDEJ
					Algoritmus KmpHledej (spuÅ¡tÄ›nÃ­ automatu na Å™etÄ›zec Ïƒ)
						Vstup: Seno Ïƒ, zkonstruovanÃ½ automat
						1. s = 0
						2. Pro znaky x âˆˆ Ïƒ postupnÄ› provÃ¡dÃ­me:
						3. s = KmpKrok(s, x)
						4. Pokud s = J, ohlÃ¡sÃ­me vÃ½skyt.

				- KMP KONSTRUKCE
					Algoritmus KmpKonstrukce
					Vstup: Jehla Î¹ dÃ©lky J
					1. Z[0] = nedefinovÃ¡no, Z[1] = 0
					2. s = 0
					3. Pro i = 2, . . . , J:
					4. s = KmpKrok(s, Î¹[i âˆ’ 1])
					5. Z[i] = s
					VÃ½stup: Pole zpÄ›tnÃ½ch hran Z

			- Algoritmus beÅ¾Ã­ v Äase O(J+S)
				- LineÃ¡rny Äas s dÄºÅ¾kou ihly(J) potrebujeme na postavenie automatu, lineÃ¡rny Äas s dÄºÅ¾kou sena potom samotnÃ© vyhÄ¾adÃ¡vanie
	}

3. printf() Dinic
	{
		Sestrojime sit rezerv, kde r(e) je rezerva hrany "e" pri toku F

		Dinic(){
			F = nulovÃ½ tok;
			while(true){
				Sestrojime sit rezerv, smazeme hrany r(e) = 0;
				l = delka nejkratsi cesty z Z do S v R.
				if(neexistuje zadna takova cesta) return F;

				Cisteni_Site(R);
				G = blokujici tok v R; //na kazde orientovane ceste z Z do S Existuje aspon 1 hrana, kde f(e) = c(e);
				zlepsime F pomoci G;
			}
		}

		Cisteni_Site(rezervni sit R){
			rozdelime vrchole do vrstem dle vzdalenosti do Z.
			odstranime vrstvy za S(vrcholy se vzdalenosti > l);
			odstranime hrany do predchozich vrstev a hrany uvnitr vrstev
			odstranime slepe ulicky: //DEGout(v) = 0
			{
				F = {v != z | DEEGout(v) = 0} //fronta ke smazani				
				while(F != 0){
					vrchol v = F.pop();
					smazeme vsechny hrany, ktere vedou do v;
					foreach(vrchol v in R) if(DEGout(v) == 0) F.add(v);
				}
			}
		}

		Blokujici_tok_Find(){
			g = nulovÃ½ tok;
			while(existuje v R orientovana cesta P(Z, S)){
				Îµ = min(r(e) - g(e)); //hrany z P
				foreach(edge e in P) g(e) = g(e) + Îµ;
				while(pro nejake e: g(e) = r(e)) smazeme e z R;
				Docistime sit pomoci Fronty; //TODO jak?
			}
			return g;
		}

		//Korektnost, TODO pomocne lemma
		Z lemmatu o zlepsovani toku F je stale korektni tok. Ale zastavi se tehdy, kdyÅ¾ neexistuje cesta z Z do S po hranach s kladnou rezervou.
		Tedy zastavil by se i FF.

		//Casova slozitost
		- sit rezerv, mazani hran s r(e) = 0,hledani nejkratsi cesty i konecne zlepsovani toku trvaji O(m);
		- cisteni site taky v O(m) (mazani hrany trva O(1), mazani incidencnich hran O(1), kaÅ¾dÃ½ vrchol i hrana jsou smazany nejvys jednou ve fazi)
		- hledani blok toku projde nejvys m cest, protoÅ¾e pokaÅ¾de ze siti vypadne aspon 1 hrana a uÅ¾ se tam nevratÃ­.
		Sit je vrstevnata => nalezt jednu cestu stihneme v O(n);
		Dohromady O(m*n + cisteni) = O(m*n)
		O(m + m + mn) = O(m*n);
	}

1. printf() Goldberg
	{
		tok Goldberg(){
			//Init
			h(z) = n;
			foreach(vrchol v in V){
				h(v) = 0;
			}
			//Starting first wave
			foreach(hrana h in H){ //All to zero
				if(h ma zdroj jako vrchol) f(h) = c(h);
				else f(h) = 0;
			}
			while(Existuje vrchol u != Z OR S, Å¾e Pritok > 0){
				if (Existuje hrana ua, r(ua)>0 AND h(u) > h(a))
				{
					pÅ™evedeme pÅ™ebytek po hranÄ› uv
				}
				else
				{
					u: ++h(u); //zvedneme u:...
				}
			}
			return max. tok f
		}

		Invarian:
		1. f je vlna
		2. h(v) nikdy neklesa
		3. h(Z) = n AND h(S) = 0
		4. prebytek S >= 0

		Dukaz indukci //TODO finish
		n = 0 -> plati
		zmena prebytku -> nevytvari zaporne

		Lemma o korektnostÃ­(v returnu je TOK a je max):
			1) vlna splnuje pozadavek na f(v) â‰¤ c(v). Chceme Kirfchhoffuv zakon: Dukaz sporem, kdyby nebyl splnen v nejakem vrcholu v, tak alg se nezastavi.
			2) f je max: Sporem, necht tok neni max -> Existuje nenasycena cesta z Z do S.
				Z ma vysku N, S - 0, takze cesta ma spad N.(ma ale jen (n-1) hran) -> najde se hrana se spadem aspoÅˆ 2 - je nenasycena, spor s Invariantem S.
		Veta o casove sloÅ¾itosti(O(n^2*m)):
			1. Init trva O(m);
			2. alg provede nejvys 2n^2 zvednuti(Lemma Z)
			3. nejvyse n*m nasycenych prevedeni
			4. nejvyse n^2*m nenasycenych prevedeni(Lemma N)
			Dohromady O(n^3 + n*m + n^2*m) = O(n^2*m)
	}
14. printf() Ford-Fulkerson
	{
		F_F(Sit S)
		{
			F = libov. tok;
			while(Existuje nenasycena cesta P z Z do S){
				Îµ = min(r(e) | e in P); //rezerva cele cesty 
				foreach(ab in P){
					d = min(f(ab), Îµ); //kolik muzeme odecist v protismeru
					f(ba) = f(ab) - d;
					f(ab) = f(ab) + Îµ - d; //zbytec pricteme v protismeru
				}
			}
			return F;
		}

		//Konecnost
		- celociselne kapacity, F v kazdem kroku se zvetsi aspon o 1, alg se zastavi po Sum(c(e)) krocich
		- racionalni: vynasobime spol nasobkem
		- irracionalni: nemusi se ani zastavit ani konvergovat k max toku
		//Spravnost
		Pokud se F_F zastavi -> vyda max tok

		UvaÅ¾ujme mnoÅ¾inu vrcholu A = {vrchol v in V | Existuje nenasycena cesta z Z do S}
		B = V\A;
		E(A,B) je Å™ez, Z lezi v A, protoÅ¾e z Z do Z existuje cesta nulove delky(nenasycena). 

		//Jednotkove kapacity
		- Jedna iterace bezi v O(m)//Cestu najdeme BFS, zlepseni je lin.
		- #iteraci je nejvys O(n), tok se zlepsi aspon o 1
		Dohromady O(mn)
	}

16. printf() Convex hull
	{
		Princip Zametani roviny

		Convex_Hull(body X[])
		{
			X.sort(dle x-ve souradnice);
			H = D += b1; //horni a dolni obaly
			foreach(bod b in X, krome b1){
				while(|H| â‰¥ 2 AND uhel H[k-1]H[k]b je orient doleva) //Prepocitame H
				{
					odebereme posledni H[k] z H;
					H += b;
				}
				//symmetricky D
			}

			return D, H;
		}

		//orientace uhlu najdeme pomoci det matice = x1y2 - x2y1

		//Casova slozitost
		Trideni trva O(n*log(n)). Kazdy bod je odebran nejvyse jednou -> vsechna odebrani trvaji O(n), pridani trva O(1). Kvuli trideni O(n*log(n))
	}
6. printf() Definujte VoronÃ©ho diagram a popiÅ¡te algoritmus na jeho konstrukci
	{
		Pro mnoÅ¾inu X1 ... Xn âˆˆ R^2 je system oblasti B1 ... Bn âŠ† R^2, Bi obsahuje body, kterÃ© jsou bliÅ¾Å¡Ã­ k Xi neÅ¾ k ostatnÃ­m Xj

		Zametani roviny zezhora

		Fortune(){
			K += vsechny mistni udalosti;//Kalendar //TODO ktere??
			zalozime prazdnou pobrezni linii P;
			while(!k.empty()){
				U = K.pop();
				if(U je mistni){
					Najdeme v P parabolu dle x souradnice mista;
					Rozdelime ji a mezi jeji casti vlozime novou parabolu;
					do diagramu pridame novou hranu, ktera zatim neni nikam pripojena;
				}
				if(U je kriznicova){
					smazeme parabolu z P;
					do diagramu zaznamename vrchol, v nemz 2 hrany konci a 1 zacina;
				}
				Po zmene pobzezi prepocitame kruznicove udalost(O(1) vznikne, O(1) zanikne);
			}
		}

		//Casova slozitost
		Celkove nastane N mistnich udalosti (na kazde X se narazime prave jednou)
		a N kruznicovych (kruznicova smaze 1 parabolu z pobrezi, parabola pribyva pouze s kazdym Xi).
		Kalendar a pobrezni linie jsou O(n) -> O(log(n)) na operaci -> O(log(n)) na kazdou udalost -> O(n*log(n));
	}
8. printf() PrÅ¯seÄÃ­ky ÃºseÄek
	{
		//Princip Zametani Roviny
		P = null; //Prurez
		K[points] += zacatky a konce usecek. //Kalendar
		while(k.empty() != true){
			U = k.pop(); //vyndame posledni udalost
			if(U == zacatek usecky) P += novou usecku;
			if(U == konec usecky) P -= usecku;
			if(U == prusecik){
				printf("Prusecik!"); prohodime usecky v P; //TODO explain this step
			}
			Prepocitame naplanovane prusecikove udalosti v okoli zmeny(nejvÃ½Å¡e dvÄ› odebereme a dvÄ› novÃ© pÅ™idÃ¡me);
		}

		//Analysis of Time complexity
		Kalendar - halda nebo vyhled. strom, vÅ¾dy ma 3n udalosti O(log(n))
		VloÅ¾Ã­me do vyhled stromu odkazy na usecky O(log(n))
		Pro kazdou udalost O(1) operace s Datovymi struktury
		Vsech n+p udalosti zpracujeme za O(log(n)*(n+p))
	}
7. scanf("Kyrylo") RychlÃ¡ Fourierova transformace
	{
		polynom_nasobeni(polynom Q, polynom P, deg N)
		{
			//Init
			Doplnime Q a P na 2*N (pokud deg(P) = deg(Q) = N)
			//Zvolme navzajem ruzna W0, W1 ... W2n-1
			Zvolime primitivni odmocninu 1 = W;
			F[] = FFT(2*N, P, W);
			G[] = FFT(2*N, Q, m);
			for(int i = 0; i < 2*N; ++i)
				R[i] = F[i]*G[i];

			FFT^(-1)(R[]); //TODO
		}

		vektor FFT(deg n, mocnina W, vektor P)
		{
			if(n == 1) Y0 = P0; return Y;

			(S0, ... Sn) = FFT (n/2, W^2, P sude);
			(L0, ... Ln) = FFT (n/2, W^2, P liche);

			for(int j = 0; j < n; ++j){
				Y[j] = S[j] + W[j] * L[j];
				Y[j+n] = S[j] - W[j] * L[j];
			}
			return Y;
		}
		//TODO korektnost napr slajdy Hrice #69

		//TODO FFT^(-1)

		//Casova slozitost
		FFT: T(n) = 2T(n/2) + O(n) a tedy T(n) = O(n*log(n)). (KuchaÅ™kovÃ¡ vÄ›ta)

		Je-li N = 2^k, pak v O(n*log(n)) lze spocitat FFT a FFT^(-1) v C^n. Nasobeni polynomu v O(n*log(n))

		funkce FFT trva (n*log(n)), nasobeni O(n).
	}

11. printf() NP-Ãºplnost: definice tÅ™Ã­d, Cookova vÄ›ta, dÅ¯kaz NP-Ãºplnosti vybranÃ©ho problÃ©mu
	{
		case P: Trida P rozhodovacich problemu (jsou resitelne v polynomiÃ¡lnÃ­m Äase).
		L âˆˆ P <-> Existuje nejaky alg. A a polynom f, pro kazdy vstup X alg A dovehne v caaw nejvyse f(|X|) a vyda vysledek A(X) = L(X)

		case NP: Trida NP, L âˆˆ NP <-> Existuje nejaky problem k âˆˆ P a polynom g,
		pro âˆ€ X je L(X) = 1 prave tehdy, pokud pro nejaky retezec y delkz nejvyse g(|x|) plati k(x,y);
		//Existuje polynomialni dlouha napoveda y. Je-li L(X) = 1, musi existovat aspon 1 napoveda, kterou alg k schvali.

		case NP-tezky: problem L je NP-tezky <-> na nej je predvoditelny kazdy problem z NP.
		case NP-Ãºplnost: Problem je NP-Ãºplny kdyÅ¾ je NP-tezky a zaroven lezi v NP.
		case Cook theorem: SAT je NP-uplny problem.
	}
13. printf() ProblÃ©m batohu â€“ pseudopolynomiÃ¡lnÃ­ algoritmus a aproximaÄnÃ­ schÃ©ma
	{
		PouÅ¾ijeme dynamickÃ© programovÃ¡nÃ­.
		//To je pÄ›knÃ½ pÅ™Ã­klad tzv. pseudopolynomiÃ¡lnÃ­ho algoritmu, tedy algoritmu,
		//jehoÅ¾ sloÅ¾itost je polynomem v poÄtu ÄÃ­sel na vstupu a jejich velikosti.
		omezime se na K prvnich predmetu, Ak(c) je minimum z hmotnosti tÄ›ch podmnoÅ¾in, jejichÅ¾ cena je prÃ¡vÄ› c.
		Pokud takova neexistuje, Ak(c) = âˆ;

		Ak spoÄitÃ¡me indukci dle k

		- k = 0, A0(0) = 0, A0(1) = A0(2) ... A0(C) = âˆ;
		- Ak(c) = min(Ak-1(c), Ak-1(c - ck) + hk);

		prechod od Ak-1 do Ak je O(C). Od A1 k An se dopocitame O(C*n);

		An(c*) â‰¤ H

		Upravime alg, aby jeÅ¡tÄ› pamatoval pro Ak(c) jeÅ¡tÄ› Bk(c) - index poslednÃ­ho pÅ™edmÄ›tu, kterÃ½ jsme do mnoÅ¾iny pÅ™idali.
		i = Bn(c*), i` = Bi-1(c* - ci). V O(n) spocitame celou B.

		V binarnim vyjadreni C muze byt exponencialni vzhledem k N - alg. je pseudopolynomialnÃ­.

		//Aproximacni
		foreach(predmet P in batohu) if(vaha P > const H) batohu.remove(P);
		C_MAX = max Ci;
		M = floor(n/e); //floor() Horni cela cast
		for(int i = 0; i < n+1; ++i)
			Ä‰[i] = trunc(C[i] * M/C_MAX); //trunc() -  dolni cela cast
		VyÅ™eÅ¡Ã­me dynamickÃ½m programovÃ¡nÃ­m problÃ©m batohu pro upravenÃ© ceny Ä‰ a pÅ¯vodnÃ­ hmotnosti i kapacitu batohu.
		Vybereme stejnÃ© pÅ™edmÄ›ty, jakÃ© pouÅ¾ilo optimÃ¡lnÃ­ Å™eÅ¡enÃ­ kvantovanÃ©ho zadÃ¡nÃ­.

		//Casova Slozitost
		Kroky 1â€“3 a 5 jistÄ› zvlÃ¡dneme v Äase ğ’ª(n).
		Krok 4 Å™eÅ¡Ã­ problÃ©m batohu se souÄtem cen Äˆ â‰¤ nM = ğ’ª(n^2/Îµ), coÅ¾ stihne v Äase ğ’ª(nÄˆ) = ğ’ª(n^3/Îµ).
		ZbÃ½vÃ¡ dokÃ¡zat, Å¾e vÃ½sledek naÅ¡eho algoritmu mÃ¡ opravdu relativnÃ­ chybu nejvÃ½Å¡e Îµ.
	Dukaz:	
		Necht P mnoÅ¾ina predmetu pouzitych v optimalni reseni ulohy, C(P) - optimalni cena
		Q - mnozina predmetu aproximacniho reseni, Ä‰(Q) - cena aprox. reseni

		Ä‰(P) = Sum(Ä‰[i]) = Sum(trunc(C[i]*M/C_MAX)) â‰¥ Sum(C[i] * M/C_MAX - 1) â‰¥ Sum(C[i]*M/C_MAX) - n = C(P) * M/C_MAX - n
		C(Q) = Sum(C[i]) â‰¥ Sum(Ä‰[i]*C_MAX/M) = C_MAX/M * Sum(Ä‰[i]) = C_MAX/M * Ä‰(Q) â‰¥ C_MAX/M * Ä‰(P)
		//posledni nerovnost PoslednÃ­ nerovnost platÃ­ proto, Å¾e Ä‰(Q) je optimÃ¡lnÃ­ Å™eÅ¡enÃ­ kvantovanÃ© Ãºlohy, zatÃ­mco Ä‰(P) je nÄ›jakÃ© dalÅ¡Ã­ Å™eÅ¡enÃ­ tÃ©Å¾e Ãºlohy, kterÃ© nemÅ¯Å¾e bÃ½t lepÅ¡Ã­.
		C(Q) â‰¥ (C(P) * M/C_MAX - n) * C_MAX/M â‰¥ C(P) - n*C_MAX/(n/Îµ) â‰¥ C(P) - Îµ*C_MAX â‰¥ C(P) - Îµ*C(P) = (1-Îµ)*C(P)

	}
5. printf() 2-aproximace problÃ©mu obchodnÃ­ho cestujÃ­cÃ­ho
	{
		//Nejkratsi z Hamiltonovskych kruznic v grafu s ohodnocenim
		if(Graf je uplny ^ plati v nem trojuhelnikova nerovnost) muzeme 2-aproximovat;
		//To znamenÃ¡ najÃ­t v polynomiÃ¡lnÃ­m Äase kruÅ¾nici,
		//kterÃ¡ je pÅ™inejhorÅ¡Ã­m dvakrÃ¡t delÅ¡Ã­ neÅ¾ ta optimÃ¡lnÃ­.

		1. Najdeme Kostru
		2. Zakoreneme naleznutou kostru
		3. Pustime DFS a poznamename v jakem poradi jsme nalezli hrany
		4. Kazdou hranu projdeme 2krat (dolu a nahoru). Upravime tento sled tak, ze kdykoliv se dostÃ¡vÃ¡ do jiÅ¾ navÅ¡tÃ­venÃ©ho vrcholu,
		pÅ™eskoÄÃ­ ho a pÅ™esune se aÅ¾ do nejbliÅ¾Å¡Ã­ho dalÅ¡Ã­ho nenavÅ¡tÃ­venÃ©ho.
		Tak ze sledu vytvoÅ™Ã­me hamiltonovskou kruÅ¾nici a jelikoÅ¾ v grafu platÃ­ trojÃºhelnÃ­kovÃ¡ nerovnost, celkovÃ¡ dÃ©lka nevzrostla.

		VÄ›ta: NalezenÃ¡ kruÅ¾nice nenÃ­ delÅ¡Ã­ neÅ¾ dvojnÃ¡sobek optima
		T je delka min Kostry. A delka kruznice v 2-apr alg., O - optimalni hamiltonovska kruznice
		A â‰¤ 2*T
		T â‰¤ O //jelikoÅ¾ z kaÅ¾dÃ© hamiltonovskÃ© kruÅ¾nice vznikne vynechÃ¡nÃ­m hrany kostra a ta nemÅ¯Å¾e bÃ½t kratÅ¡Ã­ neÅ¾ minimÃ¡lnÃ­

		A â‰¤ 2*T â‰¤ 2*O
	}

15. scanf("Kyrylo") binary addition
	{
		
	}
12. scanf("Kyrylo") HradlovÃ¡ sÃ­Å¥, kterÃ¡ o dvojici binÃ¡rnÃ­ch ÄÃ­sel zjistÃ­, zda je prvnÃ­ vÄ›tÅ¡Ã­ neÅ¾ druhÃ©.
	{
		
	}
