ADS II prakticke
#define Text
1. printf(); Najděte pro daný řetězec co nejdelší podřetězec, který je současně prefixem i suffixem (vlastním).
	{
		viz 20. PrefixFunction()
	}
14. scanf("Ivona") Náhrdelník je cyklický řetězec, který nemá určený ani začátek, ani směr čtení. Jak rozhodnout, zda jsou si dva náhrdelníky rovny?

7. scanf("Ivona") V daném řetězci nad abecedou {a,b} chceme nalézt nejdelší Fibonacciho podslovo. Fibonacciho slova jsou definována takto: F1=a, F2=b, Fn+2=FnFn+1.
16. scanf("Kyrylo") Je dán slovník a text. Navrhněte algoritmus, který pro každé slovo ze slovníku spočte, kolikrát se v textu vyskytuje jako podřetězec.
20. printf(); Jak zjistit, jestli je zadaný řetězec periodický? Tedy zda pro daný řetězec α existuje řetězec β a číslo k>1 tak, že α = βk.
	{
		Tak druhý pokus. Pomoci KMP najdu nejdelší Sufix, který je zároveň Prefixem slova (budou mě zajímat všechny takové kromě triviálního případu, když prefix = sufix = celé slovo). Pak pokud takový existuje, jeho délka je K a N se dělí beze zbytku (N - K), tak slovo je periodické.

	Pro výpočet délky takového sufixu/prefixu použijí následující funkce. Která spočítá tzv. prefixovou funkci KMP.

	void PrefixFunction(string str)
	{
	    int longest_prefix[str.length];
	    int length = 0; //Zatím nejdelší suffix
	    int i;
	 
	    longest_prefix[0] = 0;
	    i = 1;

	    while (i < str.length)
	    {
	       if (str[i] == str[length])
	       {
	           ++length;
	           longest_prefix[i] = length;
	           ++i;
	       }
	       else
	       {
	          if (length != 0)
	          {
	             length = longest_prefix[length-1];
	          }
	          else // if (length == 0)
	          {
	             longest_prefix[i] = 0;
	             ++i;
	          }
	       }
	    }
	}

	Z toho pole vezmu poslední prvek(longest_prefix[longest_prefix.Length - 1]), což je délka hledaného sufixu/prefixu K.

	Jelikož tento algoritmus je KMP a jedno porovnaní navíc, časová složitost je O(N);
	}
26. scanf("Kyrylo") Je dán text a číslo K. Nalezněte podřetězec délky K, který se v textu vyskytuje nejčastěji.
22. scanf("Kyrylo") Je dán řetězec a číslo K. Který podřetězec délky K je nejčetnější?

#define Toky
3. scanf("Ivona") Mějme děravou šachnovnici. Jak ji pokrýt kostkami 1×2 políčka?

17. scanf("Ivona") Mějme strom, jehož vrcholy jsou opatřeny celočíselnými vahami. Chceme nalézt nezávislou množinu, jejíž součet vah je největší možný.
18. scanf("Kyrylo") Zjistit, jak rychle běží Goldbergův algoritmus na síti s jednotkovými kapacitami
	{
		Ty jednotkove kapacity zaridi, ze nemame nenasycena prevedeni. To by nam zbyvala slozitost O(N^3 + NM). Jde to ale i na O(NM), kdyz si trosku vylepsime odhad poctu zvednuti.
		Diky implementaci nas jedno zvednuti stoji <= N. Kazda hrana ma dva vrcholy a kolikrat muzeme zvednout vrchol, uz vime, ze?
		Takze pro kazdou hranu mame <= 4N zvednuti, tedy cas na zvedani taky O(NM).
		MJ mi rikal jeste jinou verzi dukazu O(NM) zvednuti, a to pres scitani vstupnich a vystupnich stupnu vrcholu - nicmene uvedeny postup je taky spravny.
	}
19. printf(); Je dán orientovaný graf a jeho vrcholy u, v. Chceme nalézt co nejvíce hranově disjunktních cest z u do v.
	Za zdroj si vezmu U jako zdroj a V jako stok. Každé hraně přiřadím kapacitu 1, v případě vrcholově z disjunktních cest ještě vrcholům kapacitu 1.
	Pustím na tento graf např F-F algoritmus. Uvážím ty hrany, kterým algoritmus přiřadí tok 1. Zbývá ještě řešit případ když cesta obsahuje cyklus.
	Stačí projít graf a pokud nějaký vrchol potkám dvakrát, tak je tam cyklus, který musím smazat. Když smažu cyklus tak dostanu cestu od U do V.
	Naleznutou cestu smažu, v hledaní cest budu pokračovat pokud Tok není nulový.

	časová složitost: F-F O(m*n), jelikož cesty jsou disjunktní jejích hledaní po ukončení F-F je O(m). Takže O(m*n) dohromady.

	//Vrcholove
	Tak z vrcholu udělám hranu následujícím způsobem:
	Pro původní vrchol a přidám 2 vrcholy a1, a2. Které spojím hranou (a1, a2). Pak ještě spojím všechny vrcholy, které předtím byly spojený hranou s a: (a, b), s a2. Neboli pro všechny b : (a, b) byla hrana v původním grafu, vytvořím hranu (a2, b).

	Pak můžu použit algoritmus pro hranově disjunktní cesty na modifikovaný graf, protože vrcholově disjunktní cesta je hranové disjunktní.
8. printf(); Pro daný neorientovaný graf chceme nalézt největší k takové, že graf je hranově k-souvislý.
	{
		Když budu spouštět algoritmus na hledaní max toku na všechny dvojice vrcholu, tak určitě všechny hranově disjunktní cesty potkám několikrát.
		Takže stačí zafixovat nějaký vrchol(třeba k), označit ho za Zdroj. Za Stock budu postupně označovat vrcholy z V\{k}(Je možné taky neuvažovat sousedy k). Minimum z toku se bude rovnat hranové souvislosti grafu. Zastavím se, když počet iteraci(I) přesáhne zatím minimální tok(Protože hranová souvislost je omezená min stupněm vrcholu a 2|E|/|V|)

		Důkaz korektností: Minimální tok ze všech iteraci označím za F.
		Z Mengerové věty existuje Separator (množina hran, po odebraní kterých graf stane nesouvislý). Velikost separátoru se rovna souvislostí grafu(Označím za R) . Aspoň jeden z množiny vrcholu V1, V2, ... V(r+1), kde r+1 index, není v tom řezu-separátoru. Nechť to bude vrchol Vj. Existuje vrchol Vt z separátoru takový, že #hranově-disjunktních cest z Vt do Vj = R.

		F >= R,
		I > F
		I >= R + 1

		Z toho C = F.

		Pro orientované grafy je nutno spočítat jak Tok z vybraného vrcholu do Vi (z množiny V\{k}) z k tak o obraceně, z Vi do k.

		Takže pro neorientovaný graf |V| - 1 je max počet spuštění algoritmu na max tok, pro orientovaný 2(|V| - 1).
	}
11. printf(); Je dán neorientovaný graf a číslo k. Zjistěte, zda graf je vrcholově k-souvislý.
	{
		Tak z vrcholu udělám hranu následujícím způsobem:
		Pro původní vrchol a přidám 2 vrcholy a1, a2. Které spojím hranou (a1, a2). Pak ještě spojím všechny vrcholy, které předtím byly spojený hranou s a: (a, b), s a2. Neboli pro všechny b : (a, b) byla hrana v původním grafu, vytvořím hranu (a2, b).

		Pak můžu použit algoritmus pro hranově disjunktní cesty na modifikovaný graf, protože vrcholově disjunktní cesta je hranové disjunktní(viz 8).
	}
5. printf(); Nalezněte polynomiální algoritmus, který v daném bipartitním grafu najde nejmenší vrcholové pokrytí.
	{
		Veta (Königova): V každom bipartitonom grafe je veľkosť maximálneho párovania rovná veľkosti minimálneho vrcholového pokrytia.

		Teda problém minimálneho vrcholového pokrytia (v bipartitnom grafe) môžeme previesť na problém maximálneho párovania.

		Veta: Najväčší tok odpovedá najväčšiemu párovaniu.

		Teda následujúci príklad vyriešime tak, že zadaný bipartitný graf (V,E) pretvoríme na sieť (V',E',z,s,c) a 
		spustíme Ford-Fulkersonov algoritmus.

		Pretvorenie grafu (V,E) na (V',E',z,s,c):
		- Nájdeme partity grafu: pravá a ľavá
		- Všetky hrany zorientujeme zľava doprava
		- Pridáme zdroj z a vedieme z neho hrany do všetkých vrcholov ľavej partity
		- Pridáme spotrebič s a vedieme do neho hrany z všetkých vrcholov pravej partity
		- Všetkým hranám nastavíme jednotkovú kapacitu

		Teraz v tejto sieti nájdeme maximálny celočíselný tok. Keďže všetky hrany majú kapacitu 1, musí po všetkých hranách tiesť buď 0 alebo 1.

		Do výsledného párovania vložíme práve tie hrany pôvodného grafu, po ktorých tečie 1.

		Dôkaz správnosti (Najväčšie párovanie):
		1. sporom (Párovanie):
			Nedostali sme párovanie, teda nejaké 2 hrany majú spoločný vrchol. 
			- Pokiaľ z pravej partity: pritiekli 2 jednotky toku, ale nemajú kam odtiecť.
			- Pokiaľ z ľavej partity: musia odtiecť 2 jednotky toku, ale nemajú kam. (spor)
		2. priamo (Najväčšie)
			Z toku vytvoríme párovanie o toľko hranách, koľko je veľkosť toku a naopak, z každého párovania vieme vytvoriť celočíselný tok 
			odpovedajúci veľkosti - našli sme bijekciu, ktorá zachováva veľkosť.

		Časová zložitosť:

		Veta: Najväčšie párovanie v bipartitnom grafe nájdeme v čase O(nm). // U tohto mám poznámku od Krála: Stačí O(n^2)... tok nebude väčší, než n.

		Dôkaz: Prevedená konštrukcia: n'= n+2, m' = m+2n (vrcholy, hrany) spotrebuje čas O(n'+m'). Nájdenie max. celočíselného toku Ford-Fulkersnovým
		algoritmom trvá O(n'm') - pri jednotlivých kapacitách - jedna iterácia beží v čase O(m), nenasýtenú cestu s BFS, zlepšenie toku v lineárnom čase,
		každá iterácia zlepší tok aspoň o 1, počet iterací je obmedzená max. toku, teda najviac n. Nakoniec tok v lineárnom čase preložíme na párovanie.
		O(n'm') = O(mn). // Copy-paste z Marešových skript.

		Priestorová zložitosť:

		Priestor potrebujeme na vrcholy, hrany + zdroj, stok a nové hrany: n+2+m+2n = 3n+m+2, teda O(3n+m+2) //konštanty,
		teda O(n+m).

		Dôkaz (König):
		Pokiaľ U podmnožinou V je vrcholové pokrytie, musia hrany vedúce medzi vrcholami tejto množiny a zdrojom a stokom tvoriť rovnaký veľký rez, 
		pretože každá s,t-cesta obsahuje aspoň 1 hranu bipartitného grafu a tá je pokrytá. Analogicky vezmeme ľubovolný st-rez, *bez zväčšenia upravíme
		na st-rez používajúci iba hrany zo s do t, ktoré odpovedajú vrcholovému pokrytiu rovnakej veľkosti.* // Od 1.* po 2.* podčiarknuté a k tomu poznámka:
		// Ano, dá se i říct, že kapacity původního párování budou velké, pak FF vybere rovnou ten řez, ktorý chceš.
	}

21. scanf("Kyrylo") Jak nalézt průsečíky zadaných parabol (tvaru ax2+bx+c pro a>0)? (*) Bez omezení na a.

#define Rovina
2. scanf("Ivona") Jsou dány množiny bodů v rovině: červené a zelené. Sestrojte přímku takovou, aby na jedné její straně ležely všechny červené body, zatímco na druhé všechny zelené.
4. scanf("Ivona") Je dána množina bodů v rovině. Oploťte ji dvěma uzavřenými ploty tak, aby celková spotřeba pletiva byla minimální.
9. scanf("Kyrylo") Jsou dány dva mnohoúhelníky. Protínají se (ne nutně hranicí)?
12. scanf("Kyrylo") Navrhněte datovou strukturu, která dostane množinu obdélníků v rovině (v osové poloze) a bude umět rychle odpovídat na dotazy typu "v kolika obdélnících z množiny se nachází tento bod?".

#define Hradla
10. Navrhněte hradlovou síť, která testuje, zda se v n-bitové posloupnosti vyskytuje nějaký pevný vzorek. Výstupem nechť je ano/ne.

#define Ostatni
6. scanf("Ivona") Definujme permanent matice stejně jako determinant, ale bez znaménkového pravidla (všechny členy přispívají kladně). Chceme pro danou nula-jedničkovou matici zjistit, zda má nenulový permanent.
13. scanf("Ivona") Uvažujme problém "Je dána soustava lineárních rovnic v celých číslech. Existuje vektor složený z nul a jedniček, který ji řeší?" Dokažte, že tento problém je NP-úplný.
15. scanf("Ivona") Hledání největší nezávislé množiny v intervalovém grafu (to je graf, jehož vrcholy jsou intervaly a hrany spojují dvojice intervalů mající neprázdný průnik).
24. scanf("Kyrylo") Uvažujme problém nezávislé množiny v grafech s maximálním stupněm 4 resp. 2. Rozhodněte, zda tento problém patří do P nebo je NP-úplný.
	{
		Prevedeme na to 3,3-SAT (2 hrany ma kazdy vrchol v trojuhelniku a dale muze byt spojen s nejvyse 2 svymi negacemi, tj. nevytvorime vic nez 4 hrany).
	}
25. scanf("Kyrylo") Jsou dány Fourierovy obrazy dvou vektorů. Jak podle nich rozhodnout, zda je jeden vektor rotací druhého?
23. scanf("Kyrylo") Nalezněte polynomiální algoritmus, který v daném bipartitním grafu najde nejmenší vrcholové pokrytí.

27. Spočítejte diskrétní Fourierovu transformaci vektoru (i,-1,-i,1,i,-1,-i,1).

Teorie
4. scanf("Ivona") Aho-Corasicková pro vyhledávání v textu.
	{
	- Zobecnenie Knuthova-Morrisova-Prattova algoritmu pre viac reťazcov.
		- Opäť zostavenie automatu, ktorý má dopredné a spätné hrany.
		- Po novom zavedieme skratkové hrany:
			- Skratková hrana zo stavu β vedie do najbližšieho koncového stavu h(β) dosažiteľného z β po spätných hranách (a 			   rôzneho od β)
			- Inými slovami, skratka h(β) nám povie, aký je najdlhší vlastný suffix slova β, ktorý je ihlou.

		- Algoritmus: //Zo skrípt
			-AC KROK
				Procedura AcKrok (jeden krok automatu)
				Vstup: Jsme ve stavu s, přečetli jsme znak x
				1. Dokud Dopředu(s, x) = ∅ ∧ s 6= kořen: s ← Zpět(s).
				2. Pokud Dopředu(s, x) 6= ∅: s ← Dopředu(s, x).
				Výstup: Nový stav s

			-AC HLEDEJ
				Algoritmus AcHledej (spuštění automatu na daný řetězec)
				Vstup: Seno σ, zkonstruovaný automat
				1. s ← kořen
				2. Pro znaky x ∈ σ postupně provádíme:
				3. s ← AcKrok(s, x)
				4. j ← s
				5. Dokud j 6= ∅:
				6. Je-li Slovo(j) 6= ∅:
				7. Ohlásíme Slovo(j).
				8. j ← Zkratka(j)

			-AC KONSTRUKCE
				Algoritmus AcKonstrukce
				Vstup: Slova ι1, . . . , ιn
				1. Založíme strom, který obsahuje pouze kořen r.
				2. Vložíme do stromu slova ι1. . . ιn, nastavíme Slovo ve všech stavech.
				3. Zpět(r) ← ∅, Zkratka(r) ← ∅
				4. Založíme frontu F a vložíme do ní syny kořene.
				5. Pro všechny syny s kořene: Zpět(s) ← r, Zkratka(s) ← ∅.
				6. Dokud F 6= ∅:
				7. Vybereme i z fronty F.
				8. Pro všechny syny s vrcholu i:
				9. z ← AcKrok(Zpět(i), písmeno na hraně is)
				10. Zpět(s) ← z
				11. Pokud Slovo(z) 6= ∅: Zkratka(s) ← z.
				12. Jinak Zkratka(s) ← Zkratka(z).
				13. Vložíme s do fronty F.
				Výstup: Strom, pole Slovo, Zpět a Zkratka

		- Algoritmus beží v čase e Θ ((suma)Ji + S + V)
			- J1,...,Jn sú dĺžky jednotlivých ihiel, S je dĺžka sena a V počet výskytov
	}

2. scanf("Ivona") Rabinův-Karpův algoritmus.

10. scanf("Ivona") Algoritmus Knuth-Morris-Pratt.
	{
		- Inkrementálný algoritmus
			- Opiera sa o vyhladávací automat
			- Vrcholy sú spojené hranami dvoch druhov:
				- Dopredné: popisujú rozšírenie prefixu pridaním jednoho písmena, 
				- Spätné vedú podľa spätnej funkie (z každého stavu do jeho najdlhšieho vlastného suffixu, ktorý je opäť stavom)
					- Najdlhší prefix ihly, ktorý je suffixom prehľadávaného sena.

			- Algoritmus: //Zo skrípt
				- KMP KROK
					Procedura KmpKrok (jeden krok automatu)
					Vstup: Jsme ve stavu s, přečetli jsme znak x
					1. Dokud ι[s] 6= x ∧ s 6= 0 : s ← Z[s]. / zpětné hrany
					2. Pokud ι[s] = x, pak s ← s + 1. / dopředná hrana
					Výstup: Nový stav s

				- KMP HLEDEJ
					Algoritmus KmpHledej (spuštění automatu na řetězec σ)
						Vstup: Seno σ, zkonstruovaný automat
						1. s ← 0
						2. Pro znaky x ∈ σ postupně provádíme:
						3. s ← KmpKrok(s, x)
						4. Pokud s = J, ohlásíme výskyt.

				- KMP KONSTRUKCE
					Algoritmus KmpKonstrukce
					Vstup: Jehla ι délky J
					1. Z[0] ← nedefinováno, Z[1] ← 0
					2. s ← 0
					3. Pro i = 2, . . . , J:
					4. s ← KmpKrok(s, ι[i − 1])
					5. Z[i] ← s
					Výstup: Pole zpětných hran Z

			- Algoritmus beží v čase O(J+S)
				- Lineárny čas s dĺžkou ihly(J) potrebujeme na postavenie automatu, lineárny čas s dĺžkou sena potom samotné 				  vyhľadávanie
	}

3. scanf("Ivona") Dinic

1. printf(); Goldberg
	{
		tok Goldberg(){
			//Init
			h(z) = n;
			foreach(vrchol v in V){
				h(v) = 0;
			}
			//Starting first wave
			foreach(hrana h in H){ //All to zero
				if(h ma zdroj jako vrchol) f(h) = c(h);
				else f(h) = 0;
			}
			while(Existuje vrchol u != Z OR S, že Pritok > 0){
				if (Existuje hrana ua, r(ua)>0 AND h(u) > h(a))
				{
					převedeme přebytek po hraně uv
				}
				else
				{
					u: ++h(u); //zvedneme u:...
				}
			}
			return max. tok f
		}

		Invarian:
		1. f je vlna
		2. h(v) nikdy neklesa
		3. h(Z) = n AND h(S) = 0
		4. prebytek S >= 0

		Dukaz indukci //TODO finish
		n = 0 -> plati
		zmena prebytku -> nevytvari zaporne

		Lemma o korektností(v returnu je TOK a je max):
			1) vlna splnuje pozadavek na f(v) <= c(v). Chceme Kirfchhoffuv zakon: Dukaz sporem, kdyby nebyl splnen v nejakem vrcholu v, tak alg se nezastavi.
			2) f je max: Sporem, necht tok neni max -> Existuje nenasycena cesta z Z do S.
				Z ma vysku N, S - 0, takze cesta ma spad N.(ma ale jen (n-1) hran) -> najde se hrana se spadem aspoň 2 - je nenasycena, spor s Invariantem S.
		Veta o casove složitosti(O(n^2*m)):
			1. Init trva O(m);
			2. alg provede nejvys 2n^2 zvednuti(Lemma Z)
			3. nejvyse n*m nasycenych prevedeni
			4. nejvyse n^2*m nenasycenych prevedeni(Lemma N)
			Dohromady O(n^3 + n*m + n^2*m) = O(n^2*m)
	}
14. scanf("Ivona") Ford-Fulkerson

16. scanf("Ivona") Convex hull
6. scanf("Ivona") Definujte Voroného diagram a popište algoritmus na jeho konstrukci
8. printf(); Průsečíky úseček
	{
		//Princip Zametani Roviny
		P = null; //Prurez
		K[points] += zacatky a konce usecek. //Kalendar
		while(k.empty() != true){
			U = k.pop(); //vyndame posledni udalost
			if(U == zacatek usecky) P += novou usecku;
			if(U == konec usecky) P -= usecku;
			if(U == prusecik){
				printf("Prusecik!"); prohodime usecky v P; //TODO explain this step
			}
			Prepocitame naplanovane prusecikove udalosti v okoli zmeny(nejvýše dvě odebereme a dvě nové přidáme);
		}

		//Analysis of Time complexity
		Kalendar - halda nebo vyhled. strom, vždy ma 3n udalosti O(log(n))
		Vložíme do vyhled stromu odkazy na usecky O(log(n))
		Pro kazdou udalost O(1) operace s Datovymi struktury
		Vsech n+p udalosti zpracujeme za O(log(n)*(n+p))
	}
7. scanf("Kyrylo") Rychlá Fourierova transformace
	{

	}

11. printf(); NP-úplnost: definice tříd, Cookova věta, důkaz NP-úplnosti vybraného problému
	{
		case P: Trida P rozhodovacich problemu (jsou resitelne v polynomiálním čase).
		L ∈ P <-> Existuje nejaky alg. A a polynom f, pro kazdy vstup X alg A dovehne v caaw nejvyse f(|X|) a vyda vysledek A(X) = L(X)

		case NP: Trida NP, L ∈ NP <-> Existuje nejaky problem k ∈ P a polynom g,
		pro vsechna X je L(X) = 1 prave tehdy, pokud pro nejaky retezec y delkz nejvyse g(|x|) plati k(x,y);
		//Existuje polynomialni dlouha napoveda y. Je-li L(X) = 1, musi existovat aspon 1 napoveda, kterou alg k schvali.

		case NP-tezky: problem L je NP-tezky <-> na nej je predvoditelny kazdy problem z NP.
		case NP-úplnost: Problem je NP-úplny když je NP-tezky a zaroven lezi v NP.
		case Cook theorem: SAT je NP-uplny problem.
	}
13. scanf("Kyrylo") Problém batohu – pseudopolynomiální algoritmus a aproximační schéma.
5. scanf("Kyrylo") 2-aproximace problému obchodního cestujícího.

15. scanf("Kyrylo") binary addition
12. scanf("Kyrylo") Hradlová síť, která o dvojici binárních čísel zjistí, zda je první větší než druhé.
